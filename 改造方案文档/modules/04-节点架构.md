# èŠ‚ç‚¹æ¶æ„

> **ç‰ˆæœ¬ï¼š** v2.0
> **çŠ¶æ€ï¼š** è®¾è®¡å®Œæˆ
> **æ›´æ–°æ—¥æœŸï¼š** 2025-11-10

[â† è¿”å›æ€»è§ˆ](../00-æ€»è§ˆä¸å¯¼èˆª.md)

---

## ğŸ“‹ ç›®å½•

- [å››å±‚èŠ‚ç‚¹æ¶æ„](#å››å±‚èŠ‚ç‚¹æ¶æ„)
- [ç¤¾åŒºèŠ‚ç‚¹åŠ¨æ€åŒ–æ”¹é€ ](#ç¤¾åŒºèŠ‚ç‚¹åŠ¨æ€åŒ–æ”¹é€ )
- [å‡­è¯ç³»ç»Ÿè‡ªåŠ¨è½¬æ¢](#å‡­è¯ç³»ç»Ÿè‡ªåŠ¨è½¬æ¢)
- [å·¥ä½œæµå¯¼å…¥è½¬æ¢](#å·¥ä½œæµå¯¼å…¥è½¬æ¢)
- [åºŸå¼ƒçš„åŠŸèƒ½](#åºŸå¼ƒçš„åŠŸèƒ½)
- [å®‰å…¨æœºåˆ¶](#å®‰å…¨æœºåˆ¶)

---

## ğŸ”Œ å››å±‚èŠ‚ç‚¹æ¶æ„

### æ¶æ„æ¦‚è§ˆ

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  å¤šç§Ÿæˆ· SaaS å¹³å° - å››å±‚èŠ‚ç‚¹æ¶æ„                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                              â”‚
â”‚  1ï¸âƒ£ å†…ç½®èŠ‚ç‚¹ï¼ˆBuiltin Nodesï¼‰                                â”‚
â”‚     â”œâ”€ 142ä¸ªåŸºç¡€èŠ‚ç‚¹                                          â”‚
â”‚     â”œâ”€ å­˜å‚¨ä½ç½®ï¼šæ–‡ä»¶ç³»ç»Ÿï¼ˆåªè¯»ï¼‰                              â”‚
â”‚     â”œâ”€ åŠ è½½æ–¹å¼ï¼šDirectoryLoader                             â”‚
â”‚     â”œâ”€ å¯ç”¨èŒƒå›´ï¼šæ‰€æœ‰ç§Ÿæˆ·å…±äº«                                  â”‚
â”‚     â””â”€ ç»´æŠ¤è€…ï¼šå¹³å°ç»Ÿä¸€ç»´æŠ¤å’Œæ›´æ–°                              â”‚
â”‚                                                              â”‚
â”‚  2ï¸âƒ£ å¹³å°èŠ‚ç‚¹ï¼ˆPlatform Nodesï¼‰                               â”‚
â”‚     â”œâ”€ å¹³å°å®˜æ–¹èŠ‚ç‚¹ï¼ˆOpenAI, Claude, Geminiç­‰ï¼‰                â”‚
â”‚     â”œâ”€ ç¬¬ä¸‰æ–¹å®¡æ ¸é€šè¿‡èŠ‚ç‚¹ï¼ˆStripe, Airtableç­‰ï¼‰                â”‚
â”‚     â”œâ”€ å­˜å‚¨ä½ç½®ï¼šæ•°æ®åº“ï¼ˆplatform_nodeè¡¨ï¼‰                     â”‚
â”‚     â”œâ”€ åŠ è½½æ–¹å¼ï¼šæ•°æ®åº“åŠ è½½ + VM2æ²™ç®±ç¼–è¯‘                       â”‚
â”‚     â”œâ”€ å¯ç”¨èŒƒå›´ï¼šæ‰€æœ‰ç§Ÿæˆ·å¯ç”¨                                  â”‚
â”‚     â”œâ”€ è®¡è´¹æ–¹å¼ï¼šæŒ‰é‡è®¡è´¹ï¼ˆå¹³å°ç»Ÿä¸€ç®¡ç†API Keyï¼‰                â”‚
â”‚     â””â”€ ç»´æŠ¤è€…ï¼šç®¡ç†å‘˜ç®¡ç†                                     â”‚
â”‚                                                              â”‚
â”‚  3ï¸âƒ£ å·¥ä½œç©ºé—´ç§æœ‰èŠ‚ç‚¹ï¼ˆWorkspace Private Nodesï¼‰               â”‚
â”‚     â”œâ”€ 3.1 npmç¤¾åŒºèŠ‚ç‚¹ï¼ˆæ¨èï¼‰âœ… æ–°å¢                          â”‚
â”‚     â”‚   â”œâ”€ ç”¨æˆ·ä»npm registryå®‰è£…                            â”‚
â”‚     â”‚   â”œâ”€ åç«¯ä¸‹è½½ â†’ æå–ä»£ç  â†’ å­˜å‚¨åˆ°æ•°æ®åº“                  â”‚
â”‚     â”‚   â”œâ”€ è‡ªåŠ¨è½¬æ¢å‡­è¯ä¸ºèŠ‚ç‚¹å‚æ•°                             â”‚
â”‚     â”‚   â”œâ”€ ä»…å®‰è£…çš„å·¥ä½œç©ºé—´å¯è§                               â”‚
â”‚     â”‚   â””â”€ ä¿ç•™n8nç”Ÿæ€ä¼˜åŠ¿                                    â”‚
â”‚     â”‚                                                         â”‚
â”‚     â””â”€ 3.2 ç”¨æˆ·ä¸Šä¼ èŠ‚ç‚¹                                       â”‚
â”‚         â”œâ”€ ç”¨æˆ·è‡ªå·±ç¼–å†™çš„èŠ‚ç‚¹ä»£ç                              â”‚
â”‚         â”œâ”€ ç›´æ¥ä¸Šä¼ åˆ°æ•°æ®åº“                                   â”‚
â”‚         â”œâ”€ ä»…ä¸Šä¼ è€…å·¥ä½œç©ºé—´å¯è§                               â”‚
â”‚         â”œâ”€ VM2æ²™ç®±è¿è¡Œ                                        â”‚
â”‚         â””â”€ å¯æäº¤å®¡æ ¸æˆä¸ºå¹³å°èŠ‚ç‚¹                             â”‚
â”‚                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### èŠ‚ç‚¹åŠ è½½æœºåˆ¶

```typescript
// packages/cli/src/load-nodes-and-credentials.ts

@Service()
export class LoadNodesAndCredentials {
  /**
   * è·å–æ‰€æœ‰å¯ç”¨èŠ‚ç‚¹ï¼ˆæ ¹æ®å·¥ä½œç©ºé—´ï¼‰
   */
  async getAllNodeTypes(workspaceId?: string): Promise<INodeTypeNameIndex> {
    // 1. åŠ è½½å†…ç½®èŠ‚ç‚¹ï¼ˆ142ä¸ªï¼Œä»æ–‡ä»¶ç³»ç»Ÿï¼‰
    const builtinNodes = await this.loadBuiltinNodes();

    // 2. åŠ è½½å¹³å°èŠ‚ç‚¹ï¼ˆä» platform_node è¡¨ï¼‰
    const platformNodes = await this.loadPlatformNodes();

    // 3. åŠ è½½å·¥ä½œç©ºé—´ç§æœ‰èŠ‚ç‚¹ï¼ˆä» custom_node è¡¨ï¼‰âœ… åŒ…å« npm ç¤¾åŒºèŠ‚ç‚¹
    const workspaceNodes = workspaceId
      ? await this.loadWorkspaceNodes(workspaceId)
      : {};

    // 4. éªŒè¯å¹¶åˆå¹¶ï¼ˆä¼˜é›…é™çº§ï¼‰
    return this.validateAndMerge(builtinNodes, platformNodes, workspaceNodes);
  }

  /**
   * åŠ è½½å·¥ä½œç©ºé—´èŠ‚ç‚¹ï¼ˆåŒ…å« npm ç¤¾åŒºèŠ‚ç‚¹å’Œç”¨æˆ·ä¸Šä¼ èŠ‚ç‚¹ï¼‰
   */
  private async loadWorkspaceNodes(workspaceId: string): Promise<INodeTypeNameIndex> {
    const nodeTypes: INodeTypeNameIndex = {};

    try {
      // æŸ¥è¯¢è¯¥å·¥ä½œç©ºé—´çš„æ‰€æœ‰è‡ªå®šä¹‰èŠ‚ç‚¹ï¼ˆåŒ…æ‹¬ npm å’Œç”¨æˆ·ä¸Šä¼ ï¼‰
      const customNodes = await this.customNodeService.getWorkspaceNodes(workspaceId);

      for (const node of customNodes) {
        try {
          // ç¼–è¯‘èŠ‚ç‚¹ä»£ç 
          const NodeClass = this.compileNodeCode(node.nodeCode);
          const nodeInstance = new NodeClass();

          this.validateNodeMetadata(nodeInstance.description);

          nodeTypes[node.nodeKey] = {
            type: nodeInstance,
            sourcePath: `custom://${node.id}`,
            source: 'custom',
            nodeSource: node.nodeSource, // 'npm_community' | 'user_upload'
            npmPackage: node.npmPackageName, // å¦‚æœæ˜¯ npm èŠ‚ç‚¹ï¼Œæ˜¾ç¤ºåŒ…å
          };
        } catch (error) {
          this.logger.warn(`Failed to load custom node ${node.nodeKey}:`, error);
        }
      }
    } catch (error) {
      this.logger.error('Failed to load workspace nodes:', error);
    }

    return nodeTypes;
  }

  /**
   * ç¼–è¯‘èŠ‚ç‚¹ä»£ç ï¼ˆå®‰å…¨æ²™ç®±ï¼‰
   */
  private compileNodeCode(code: string): any {
    const { VM } = require('vm2');
    const vm = new VM({
      timeout: 5000,
      sandbox: {
        require: this.createSandboxRequire(),
      },
    });

    const compiledCode = vm.run(code);

    if (typeof compiledCode !== 'function') {
      throw new Error('Node code must export a class');
    }

    return compiledCode;
  }

  /**
   * åˆ›å»ºå®‰å…¨çš„ require å‡½æ•°
   */
  private createSandboxRequire() {
    const allowedModules = ['n8n-workflow', 'n8n-core'];

    return (moduleName: string) => {
      if (!allowedModules.includes(moduleName)) {
        throw new Error(`Module ${moduleName} is not allowed`);
      }
      return require(moduleName);
    };
  }

  /**
   * é‡æ–°åŠ è½½å·¥ä½œç©ºé—´èŠ‚ç‚¹ï¼ˆå®‰è£…/å¸è½½åè°ƒç”¨ï¼‰
   */
  async reloadWorkspaceNodes(workspaceId: string) {
    // æ¸…é™¤ç¼“å­˜
    delete this.nodeTypesCache[workspaceId];

    // é‡æ–°åŠ è½½
    await this.getAllNodeTypes(workspaceId);

    this.logger.info(`Reloaded nodes for workspace ${workspaceId}`);
  }
}
```

---

## ğŸŒ ç¤¾åŒºèŠ‚ç‚¹åŠ¨æ€åŒ–æ”¹é€ 

### é—®é¢˜èƒŒæ™¯

**åŸ n8n ç¤¾åŒºèŠ‚ç‚¹å®‰è£…æœºåˆ¶çš„é—®é¢˜ï¼š**

| é—®é¢˜ | å½±å“ | ä¸¥é‡æ€§ |
|------|------|--------|
| **å®‰å…¨é£é™©** | æ¶æ„ç”¨æˆ·å¯ä»¥å®‰è£…æ¶æ„ä»£ç ï¼Œå½±å“æ•´ä¸ªæœåŠ¡å™¨å’Œæ‰€æœ‰ç§Ÿæˆ· | ğŸ”´ **è‡´å‘½** |
| **éš”ç¦»é—®é¢˜** | ç§Ÿæˆ·Aå®‰è£…çš„èŠ‚ç‚¹ï¼Œç§Ÿæˆ·Bä¹Ÿèƒ½çœ‹åˆ°å’Œä½¿ç”¨ | ğŸ”´ **ä¸¥é‡** |
| **ç‰ˆæœ¬å†²çª** | ä¸åŒç§Ÿæˆ·éœ€è¦åŒä¸€åŒ…çš„ä¸åŒç‰ˆæœ¬ï¼Œæ— æ³•éš”ç¦» | ğŸŸ¡ ä¸­ç­‰ |
| **æƒé™æ··ä¹±** | æ™®é€šç”¨æˆ·ä¸åº”è¯¥æœ‰ä¿®æ”¹æœåŠ¡å™¨æ–‡ä»¶ç³»ç»Ÿçš„æƒé™ | ğŸ”´ **ä¸¥é‡** |

### è§£å†³æ–¹æ¡ˆï¼šnpm â†’ æ•°æ®åº“

```
ç”¨æˆ·æµè§ˆ npm ç¤¾åŒºèŠ‚ç‚¹
    â†“
ç‚¹å‡»"å®‰è£…åˆ°å·¥ä½œç©ºé—´"
    â†“
åç«¯ä» npm ä¸‹è½½åˆ°ä¸´æ—¶ç›®å½•
    â†“
æå–èŠ‚ç‚¹ä»£ç  + å…ƒæ•°æ® + å‡­è¯å®šä¹‰
    â†“
è‡ªåŠ¨è½¬æ¢å‡­è¯ä¸ºèŠ‚ç‚¹å‚æ•°ï¼ˆè§ä¸‹èŠ‚ï¼‰
    â†“
å­˜å‚¨åˆ°æ•°æ®åº“ custom_node è¡¨
    â†“
å…³è”åˆ°å½“å‰å·¥ä½œç©ºé—´
    â†“
ä»æ•°æ®åº“åŠ è½½å¹¶è¿è¡Œï¼ˆVM2æ²™ç®±ï¼‰
    â†“
æ¸…ç†ä¸´æ—¶æ–‡ä»¶
```

### æ ¸å¿ƒæœåŠ¡å®ç°

```typescript
// packages/cli/src/modules/custom-nodes/npm-download.service.ts

@Service()
export class NpmDownloadService {
  /**
   * ä» npm ä¸‹è½½èŠ‚ç‚¹å¹¶æå–ä»£ç 
   */
  async downloadAndExtract(packageName: string, version?: string) {
    const tempDir = join(this.instanceSettings.n8nFolder, 'temp', uuidv4());

    try {
      // 1. åˆ›å»ºä¸´æ—¶ç›®å½•
      await mkdir(tempDir, { recursive: true });

      // 2. ä½¿ç”¨ npm pack ä¸‹è½½
      const packageVersion = version || 'latest';
      const { stdout } = await asyncExec(
        `npm pack ${packageName}@${packageVersion} --registry=https://registry.npmjs.org`,
        { cwd: tempDir }
      );

      const tarballName = stdout.trim();

      // 3. è§£å‹
      await asyncExec(`tar -xzf ${tarballName}`, { cwd: tempDir });

      const packageDir = join(tempDir, 'package');

      // 4. è¯»å– package.json
      const packageJson = JSON.parse(
        await readFile(join(packageDir, 'package.json'), 'utf-8')
      );

      // 5. æŸ¥æ‰¾èŠ‚ç‚¹æ–‡ä»¶å’Œå‡­è¯æ–‡ä»¶
      const nodeFiles = await this.findNodeFiles(packageDir);
      const credentialFiles = await this.findCredentialFiles(packageDir);

      // 6. æå–å‡­è¯å®šä¹‰
      const credentialDefinitions = await this.extractCredentialDefinitions(
        credentialFiles,
      );

      // 7. æå–å¹¶è½¬æ¢èŠ‚ç‚¹ï¼ˆè‡ªåŠ¨å¤„ç†å‡­è¯ï¼‰
      const nodes = await Promise.all(
        nodeFiles.map(file =>
          this.extractAndConvertNodeData(
            file,
            packageJson,
            credentialDefinitions
          )
        ),
      );

      return nodes[0];

    } finally {
      // 8. æ¸…ç†ä¸´æ—¶ç›®å½•
      await rm(tempDir, { recursive: true, force: true });
    }
  }

  /**
   * æŸ¥æ‰¾èŠ‚ç‚¹æ–‡ä»¶ï¼ˆ.node.ts æˆ– .node.jsï¼‰
   */
  private async findNodeFiles(packageDir: string): Promise<string[]> {
    const files: string[] = [];

    const findFiles = async (dir: string) => {
      const entries = await readdir(dir, { withFileTypes: true });

      for (const entry of entries) {
        const fullPath = join(dir, entry.name);

        if (entry.isDirectory() && entry.name !== 'node_modules') {
          await findFiles(fullPath);
        } else if (entry.isFile() && /\.node\.(ts|js)$/.test(entry.name)) {
          files.push(fullPath);
        }
      }
    };

    await findFiles(packageDir);
    return files;
  }

  /**
   * æŸ¥æ‰¾å‡­è¯æ–‡ä»¶ï¼ˆ.credentials.ts æˆ– .credentials.jsï¼‰
   */
  private async findCredentialFiles(packageDir: string): Promise<string[]> {
    // å®ç°ç±»ä¼¼äº findNodeFiles
  }
}
```

### API æ¥å£

```typescript
// packages/cli/src/modules/custom-nodes/custom-nodes.controller.ts

@RestController('/custom-nodes')
export class CustomNodesController {

  /**
   * ä» npm å®‰è£…ç¤¾åŒºèŠ‚ç‚¹åˆ°å·¥ä½œç©ºé—´
   */
  @Post('/install-from-npm')
  @GlobalScope('customNode:create')
  async installFromNpm(req: AuthenticatedRequest) {
    const { packageName, version } = req.body;
    const workspaceId = req.workspaceContext.workspaceId;

    // 1. æ£€æŸ¥å·¥ä½œç©ºé—´èŠ‚ç‚¹æ•°é‡é™åˆ¶ï¼ˆä¾‹å¦‚ï¼š50ä¸ªï¼‰
    const nodeCount = await this.customNodeService.getWorkspaceNodeCount(workspaceId);
    if (nodeCount >= 50) {
      throw new BadRequestError('å·¥ä½œç©ºé—´èŠ‚ç‚¹æ•°é‡å·²è¾¾ä¸Šé™ï¼ˆ50ä¸ªï¼‰');
    }

    // 2. æ£€æŸ¥è¯¥èŠ‚ç‚¹æ˜¯å¦å·²å®‰è£…
    const existing = await this.customNodeService.findByNpmPackage(
      workspaceId,
      packageName
    );
    if (existing) {
      throw new BadRequestError(`èŠ‚ç‚¹ ${packageName} å·²å®‰è£…`);
    }

    // 3. ä» npm ä¸‹è½½å¹¶è½¬æ¢
    const nodeData = await this.npmDownloadService.downloadAndExtract(
      packageName,
      version
    );

    // 4. å®‰å…¨éªŒè¯
    await this.nodeSecurityService.validateNodeCode(nodeData.code);

    // 5. å­˜å‚¨åˆ°æ•°æ®åº“
    const customNode = await this.customNodeService.create({
      workspaceId,
      nodeKey: nodeData.nodeKey,
      nodeName: nodeData.nodeName,
      nodeSource: 'npm_community',
      npmPackageName: packageName,
      npmVersion: nodeData.version,
      npmAuthor: nodeData.author,
      nodeCode: nodeData.code,
      metadata: nodeData.metadata,
    });

    // 6. è§¦å‘èŠ‚ç‚¹é‡æ–°åŠ è½½
    await this.loadNodesAndCredentials.reloadWorkspaceNodes(workspaceId);

    // 7. WebSocket é€šçŸ¥å‰ç«¯
    this.push.sendToWorkspace(workspaceId, {
      type: 'reloadNodeType',
      data: { nodeKey: nodeData.nodeKey }
    });

    return customNode;
  }

  /**
   * ç”¨æˆ·ä¸Šä¼ è‡ªå®šä¹‰èŠ‚ç‚¹ä»£ç 
   */
  @Post('/upload')
  @GlobalScope('customNode:create')
  async uploadCustomNode(req: AuthenticatedRequest) {
    const { nodeKey, nodeName, nodeCode } = req.body;
    const workspaceId = req.workspaceContext.workspaceId;

    // å®‰å…¨éªŒè¯
    await this.nodeSecurityService.validateNodeCode(nodeCode);

    const customNode = await this.customNodeService.create({
      workspaceId,
      nodeKey,
nodeName,
      nodeSource: 'user_upload',
      nodeCode,
    });

    await this.loadNodesAndCredentials.reloadWorkspaceNodes(workspaceId);

    return customNode;
  }

  /**
   * å¸è½½èŠ‚ç‚¹
   */
  @Delete('/:nodeId')
  @GlobalScope('customNode:delete')
  async uninstallNode(req: AuthenticatedRequest) {
    const { nodeId } = req.params;
    const workspaceId = req.workspaceContext.workspaceId;

    const node = await this.customNodeService.findById(nodeId);

    if (!node || node.workspaceId !== workspaceId) {
      throw new NotFoundError('èŠ‚ç‚¹ä¸å­˜åœ¨');
    }

    await this.customNodeService.delete(nodeId);
    await this.loadNodesAndCredentials.reloadWorkspaceNodes(workspaceId);

    this.push.sendToWorkspace(workspaceId, {
      type: 'removeNodeType',
      data: { nodeKey: node.nodeKey }
    });

    return { success: true };
  }
}
```

---

## ğŸ”„ å‡­è¯ç³»ç»Ÿè‡ªåŠ¨è½¬æ¢

### é—®é¢˜åˆ†æ

åŸ n8n ç¤¾åŒºèŠ‚ç‚¹éƒ½åŸºäºå‡­è¯ï¼ˆCredentialsï¼‰ç³»ç»Ÿè®¾è®¡ï¼Œä½†æˆ‘ä»¬çš„æ”¹é€ æ–¹æ¡ˆåºŸå¼ƒäº†å‡­è¯ç³»ç»Ÿã€‚éœ€è¦åœ¨å¯¼å…¥èŠ‚ç‚¹æ—¶è‡ªåŠ¨è½¬æ¢ã€‚

### è½¬æ¢ç­–ç•¥

```
åŸèŠ‚ç‚¹ä»£ç ï¼ˆåŒ…å«å‡­è¯ï¼‰
    â†“
AST è§£æèŠ‚ç‚¹æè¿°
    â†“
æå–å‡­è¯å¼•ç”¨å’Œå®šä¹‰
    â†“
è½¬æ¢ä¸ºèŠ‚ç‚¹å‚æ•°
    â†“
é‡å†™ä»£ç ï¼ˆgetCredentials â†’ getNodeParameterï¼‰
    â†“
ç”Ÿæˆæ— å‡­è¯ç‰ˆæœ¬
```

### è½¬æ¢ç¤ºä¾‹

#### è½¬æ¢å‰ï¼ˆåŸç¤¾åŒºèŠ‚ç‚¹ï¼‰

```typescript
export class TelegramNode implements INodeType {
  description: INodeTypeDescription = {
    displayName: 'Telegram',
    name: 'telegram',
    // âŒ ä¾èµ–å‡­è¯ç³»ç»Ÿ
    credentials: [
      {
        name: 'telegramApi',
        required: true,
      },
    ],
    properties: [
      {
        displayName: 'Resource',
        name: 'resource',
        type: 'options',
        options: [{ name: 'Message', value: 'message' }],
      },
    ],
  };

  async execute() {
    // âŒ ä½¿ç”¨å‡­è¯ API
    const credentials = await this.getCredentials('telegramApi');
    const apiToken = credentials.apiToken as string;
    const chatId = this.getNodeParameter('chatId', 0) as string;

    await telegram.sendMessage(apiToken, chatId, message);
  }
}
```

#### è½¬æ¢åï¼ˆè‡ªåŠ¨ç”Ÿæˆï¼‰

```typescript
export class TelegramNode implements INodeType {
  description: INodeTypeDescription = {
    displayName: 'Telegram',
    name: 'telegram',
    credentials: [], // âœ… æ¸…ç©º
    properties: [
      // âœ… è‡ªåŠ¨æ·»åŠ è®¤è¯å­—æ®µ
      {
        displayName: 'è®¤è¯ä¿¡æ¯',
        name: 'authentication',
        type: 'collection',
        default: {},
        options: [
          {
            displayName: 'API Token',
            name: 'credential_apiToken',
            type: 'string',
            default: '',
            required: true,
          },
        ],
      },
      {
        displayName: 'Resource',
        name: 'resource',
        type: 'options',
        options: [{ name: 'Message', value: 'message' }],
      },
    ],
  };

  async execute() {
    // âœ… è‡ªåŠ¨æ›¿æ¢
    const credentials = this.getNodeParameter('authentication', 0);
    const apiToken = credentials.credential_apiToken as string;
    const chatId = this.getNodeParameter('chatId', 0) as string;

    await telegram.sendMessage(apiToken, chatId, message);
  }
}
```

### æ ¸å¿ƒè½¬æ¢æœåŠ¡

```typescript
// packages/cli/src/modules/custom-nodes/credential-converter.service.ts

@Service()
export class CredentialConverterService {
  /**
   * è½¬æ¢åŒ…å«å‡­è¯çš„èŠ‚ç‚¹ä»£ç 
   */
  async convertNode(
    nodeCode: string,
    credentialDefinitions: Record<string, any>,
  ): Promise<ConversionResult> {
    const warnings: string[] = [];

    try {
      // 1. è§£æèŠ‚ç‚¹ä»£ç ï¼ˆä½¿ç”¨ TypeScript ASTï¼‰
      const sourceFile = ts.createSourceFile(
        'node.ts',
        nodeCode,
        ts.ScriptTarget.Latest,
        true,
      );

      // 2. æŸ¥æ‰¾èŠ‚ç‚¹æè¿°å¯¹è±¡
      const nodeDescription = this.extractNodeDescription(sourceFile);

      if (!nodeDescription.credentials || nodeDescription.credentials.length === 0) {
        // æ²¡æœ‰å‡­è¯ä¾èµ–ï¼Œæ— éœ€è½¬æ¢
        return {
          convertedCode: nodeCode,
          convertedDescription: nodeDescription,
          credentialFields: [],
          warnings: [],
        };
      }

      // 3. æ”¶é›†æ‰€æœ‰å‡­è¯å­—æ®µ
      const credentialFields: INodePropertyOptions[] = [];

      for (const credentialRef of nodeDescription.credentials) {
        const credentialType = credentialDefinitions[credentialRef.name];

        if (!credentialType) {
          warnings.push(`æœªæ‰¾åˆ°å‡­è¯å®šä¹‰: ${credentialRef.name}`);
          continue;
        }

        credentialFields.push(...credentialType.properties);
      }

      // 4. è½¬æ¢èŠ‚ç‚¹æè¿°ï¼ˆæ·»åŠ å‡­è¯å­—æ®µåˆ° propertiesï¼‰
      const convertedDescription = this.convertDescription(
        nodeDescription,
        credentialFields,
      );

      // 5. è½¬æ¢èŠ‚ç‚¹ä»£ç ï¼ˆé‡å†™ getCredentials è°ƒç”¨ï¼‰
      const convertedCode = this.convertCode(
        sourceFile,
        nodeDescription.credentials,
        credentialFields,
      );

      return {
        convertedCode,
        convertedDescription,
        credentialFields,
        warnings,
      };

    } catch (error) {
      this.logger.error('å‡­è¯è½¬æ¢å¤±è´¥:', error);
      throw new Error(`å‡­è¯è½¬æ¢å¤±è´¥: ${error.message}`);
    }
  }

  /**
   * è½¬æ¢èŠ‚ç‚¹ä»£ç ï¼ˆAST è½¬æ¢ï¼‰
   */
  private convertCode(
    sourceFile: ts.SourceFile,
    credentials: INodeCredentialDescription[],
    credentialFields: INodePropertyOptions[],
  ): string {
    const transformer: ts.TransformerFactory<ts.SourceFile> = (context) => {
      return (rootNode) => {
        const visit = (node: ts.Node): ts.Node => {
          // æŸ¥æ‰¾ this.getCredentials() è°ƒç”¨
          if (
            ts.isCallExpression(node) &&
            ts.isPropertyAccessExpression(node.expression) &&
            node.expression.name.text === 'getCredentials'
          ) {
            // æ›¿æ¢ä¸º this.getNodeParameter('authentication', 0)
            return this.replaceGetCredentialsCall(node, credentialFields);
          }

          return ts.visitEachChild(node, visit, context);
        };

        return ts.visitNode(rootNode, visit);
      };
    };

    const result = ts.transform(sourceFile, [transformer]);
    const printer = ts.createPrinter();
    return printer.printFile(result.transformed[0]);
  }
}
```

---

## ğŸ“¥ å·¥ä½œæµå¯¼å…¥è½¬æ¢

### é—®é¢˜åœºæ™¯

ç”¨æˆ·å¯èƒ½ä»åŸç‰ˆ n8n æˆ–å…¶ä»–åœ°æ–¹å¯¼å…¥åŒ…å«å‡­è¯å¼•ç”¨çš„å·¥ä½œæµ JSONã€‚

### å…¸å‹å·¥ä½œæµ JSON

```json
{
  "name": "å‘é€ Telegram æ¶ˆæ¯",
  "nodes": [
    {
      "parameters": {
        "resource": "message",
        "chatId": "123456789",
        "text": "Hello World"
      },
      "name": "Telegram",
      "type": "n8n-nodes-base.telegram",
      // âŒ å‡­è¯å¼•ç”¨ï¼ˆID: 1ï¼‰
      "credentials": {
        "telegramApi": {
          "id": "1",
          "name": "æˆ‘çš„ Telegram Bot"
        }
      }
    }
  ]
}
```

### è½¬æ¢æµç¨‹

```
å¯¼å…¥å·¥ä½œæµ JSON
    â†“
åˆ†ææ¯ä¸ªèŠ‚ç‚¹
    â†“
æ£€æµ‹åˆ° credentials å­—æ®µ
    â†“
è¯†åˆ«å‡­è¯ç±»å‹ â†’ æŸ¥æ‰¾å­—æ®µå®šä¹‰
    â†“
åˆ›å»ºå ä½ç¬¦å‚æ•°ï¼ˆå¾…ç”¨æˆ·å¡«å†™ï¼‰
    â†“
ç§»é™¤ credentials å¼•ç”¨
    â†“
æ ‡è®°èŠ‚ç‚¹éœ€è¦é…ç½®
    â†“
è¿”å›è½¬æ¢åçš„å·¥ä½œæµ + é…ç½®è¡¨å•
    â†“
å‰ç«¯æç¤ºç”¨æˆ·å¡«å†™è®¤è¯ä¿¡æ¯
```

### å·¥ä½œæµè½¬æ¢æœåŠ¡

```typescript
// packages/cli/src/modules/workflows/workflow-converter.service.ts

@Service()
export class WorkflowConverterService {
  /**
   * è½¬æ¢åŒ…å«å‡­è¯å¼•ç”¨çš„å·¥ä½œæµ
   */
  async convertWorkflow(
    workflowData: IWorkflowBase,
    workspaceId: string,
  ): Promise<WorkflowConversionResult> {
    const warnings: string[] = [];
    const requiredCredentials: RequiredCredential[] = [];
    const convertedNodes: INode[] = [];

    const nodeTypes = await this.loadNodesAndCredentials.getAllNodeTypes(workspaceId);

    for (const node of workflowData.nodes) {
      // æ£€æŸ¥èŠ‚ç‚¹æ˜¯å¦æœ‰å‡­è¯å¼•ç”¨
      if (!node.credentials || Object.keys(node.credentials).length === 0) {
        convertedNodes.push(node);
        continue;
      }

      // è½¬æ¢èŠ‚ç‚¹
      const conversionResult = await this.convertNode(node, nodeTypes);

      convertedNodes.push(conversionResult.convertedNode);

      if (conversionResult.requiredCredentials.length > 0) {
        requiredCredentials.push(...conversionResult.requiredCredentials);
      }

      if (conversionResult.warnings.length > 0) {
        warnings.push(...conversionResult.warnings);
      }
    }

    return {
      workflow: {
        ...workflowData,
        nodes: convertedNodes,
      },
      requiredCredentials,
      warnings,
    };
  }

  /**
   * è½¬æ¢å•ä¸ªèŠ‚ç‚¹
   */
  private async convertNode(
    node: INode,
    nodeTypes: INodeTypeNameIndex,
  ) {
    const convertedNode = { ...node };
    const authentication: Record<string, any> = {};
    const requiredCredentials: RequiredCredential[] = [];

    // éå†èŠ‚ç‚¹çš„å‡­è¯å¼•ç”¨
    for (const [credentialType, credentialRef] of Object.entries(node.credentials!)) {
      const credentialDefinition = await this.getCredentialDefinition(credentialType);

      if (credentialDefinition) {
        const fields: CredentialField[] = [];

        for (const property of credentialDefinition.properties) {
          const fieldName = `credential_${property.name}`;

          // åˆ›å»ºå ä½ç¬¦ï¼ˆç”¨æˆ·éœ€è¦å¡«å†™ï¼‰
          authentication[fieldName] = '';

          fields.push({
            name: property.name,
            displayName: property.displayName,
            type: property.type,
            required: property.required ?? true,
          });
        }

        requiredCredentials.push({
          nodeId: node.id,
          nodeName: node.name,
          nodeType: node.type,
          credentialType,
          credentialName: (credentialRef as any).name || credentialType,
          fields,
        });
      }
    }

    // æ·»åŠ  authentication å‚æ•°
    if (Object.keys(authentication).length > 0) {
      convertedNode.parameters = {
        ...convertedNode.parameters,
        authentication,
      };
    }

    // ç§»é™¤å‡­è¯å¼•ç”¨
    delete convertedNode.credentials;

    return {
      convertedNode,
      requiredCredentials,
      warnings: [],
    };
  }
}
```

### å¯¼å…¥ API

```typescript
@RestController('/workflows')
export class WorkflowsController {
  /**
   * å¯¼å…¥å·¥ä½œæµ
   */
  @Post('/import')
  @GlobalScope('workflow:create')
  async importWorkflow(req: AuthenticatedRequest) {
    const { workflowData } = req.body;
    const workspaceId = req.workspaceContext.workspaceId;

    // æ‰§è¡Œå·¥ä½œæµè½¬æ¢
    const conversionResult = await this.workflowConverter.convertWorkflow(
      workflowData,
      workspaceId,
    );

    // ä¿å­˜è½¬æ¢åçš„å·¥ä½œæµï¼ˆæ ‡è®°ä¸º"éœ€è¦é…ç½®"çŠ¶æ€ï¼‰
    const workflow = await this.workflowService.create({
      ...conversionResult.workflow,
      projectId: workspaceId,
      active: false, // å¯¼å…¥åé»˜è®¤ä¸æ¿€æ´»
      settings: {
        ...conversionResult.workflow.settings,
        requiresConfiguration: conversionResult.requiredCredentials.length > 0,
      },
    });

    return {
      workflow,
      requiredCredentials: conversionResult.requiredCredentials,
      warnings: conversionResult.warnings,
      message: conversionResult.requiredCredentials.length > 0
        ? 'å·¥ä½œæµå¯¼å…¥æˆåŠŸï¼Œä½†éœ€è¦é…ç½®è®¤è¯ä¿¡æ¯æ‰èƒ½ä½¿ç”¨'
        : 'å·¥ä½œæµå¯¼å…¥æˆåŠŸ',
    };
  }

  /**
   * æ‰¹é‡å¡«å†™å‡­è¯ä¿¡æ¯ï¼ˆå¯¼å…¥åé…ç½®ï¼‰
   */
  @Post('/:id/configure-credentials')
  @GlobalScope('workflow:update')
  async configureCredentials(req: AuthenticatedRequest) {
    const { id } = req.params;
    const { credentialValues } = req.body;

    // credentialValues æ ¼å¼ï¼š
    // {
    //   "nodeId1": { "credential_apiToken": "xxxx" },
    //   "nodeId2": { ... }
    // }

    const workflow = await this.workflowService.findById(id);

    // æ›´æ–°èŠ‚ç‚¹çš„è®¤è¯å‚æ•°
    const updatedNodes = workflow.nodes.map(node => {
      if (credentialValues[node.id]) {
        return {
          ...node,
          parameters: {
            ...node.parameters,
            authentication: {
              ...node.parameters.authentication,
              ...credentialValues[node.id],
            },
          },
        };
      }
      return node;
    });

    const updatedWorkflow = await this.workflowService.update(id, {
      nodes: updatedNodes,
      settings: {
        ...workflow.settings,
        requiresConfiguration: false,
      },
    });

    return {
      workflow: updatedWorkflow,
      message: 'è®¤è¯ä¿¡æ¯é…ç½®æˆåŠŸ',
    };
  }
}
```

---

## âŒ åºŸå¼ƒçš„åŠŸèƒ½

### å®Œå…¨ç§»é™¤çš„æ¨¡å—

ä»¥ä¸‹åŸ n8n çš„ç¤¾åŒºèŠ‚ç‚¹åŠŸèƒ½åœ¨å¤šç§Ÿæˆ· SaaS æ¨¡å¼ä¸‹**ä¸å†é€‚ç”¨**ï¼Œå·²å®Œå…¨åºŸå¼ƒï¼š

#### 1. åç«¯æ¨¡å—

| æ¨¡å— | æ–‡ä»¶è·¯å¾„ | åºŸå¼ƒåŸå›  |
|------|---------|---------|
| `CommunityPackagesController` | `packages/cli/src/modules/community-packages/community-packages.controller.ts` | ç”¨æˆ·ä¸èƒ½ç›´æ¥å®‰è£…åŒ…åˆ°æœåŠ¡å™¨æ–‡ä»¶ç³»ç»Ÿ |
| `CommunityPackagesService` | `packages/cli/src/modules/community-packages/community-packages.service.ts` | npm å®‰è£…æœºåˆ¶ä¸é€‚ç”¨ |
| `InstalledPackagesRepository` | `packages/cli/src/modules/community-packages/installed-packages.repository.ts` | ç”± CustomNodeRepository æ›¿ä»£ |

#### 2. æ•°æ®åº“è¡¨

```sql
-- âŒ åˆ é™¤ç¤¾åŒºèŠ‚ç‚¹ç›¸å…³è¡¨
DROP TABLE IF EXISTS installed_packages;
DROP TABLE IF EXISTS installed_nodes;
```

#### 3. API ç«¯ç‚¹

| ç«¯ç‚¹ | æ–¹æ³• | åºŸå¼ƒåŸå›  |
|------|------|---------|
| `/community-packages` | POST | ç”¨æˆ·å®‰è£…èŠ‚ç‚¹åˆ°æœåŠ¡å™¨ |
| `/community-packages` | DELETE | ç”¨æˆ·å¸è½½èŠ‚ç‚¹ |
| `/community-packages` | PATCH | æ›´æ–°èŠ‚ç‚¹ç‰ˆæœ¬ |
| `/community-packages` | GET | è·å–å·²å®‰è£…èŠ‚ç‚¹ï¼ˆæ”¹ç”¨ `/custom-nodes`ï¼‰ |

#### 4. å‰ç«¯æ¨¡å—

| ç»„ä»¶/Store | æ–‡ä»¶è·¯å¾„ | åºŸå¼ƒåŸå›  |
|-----------|---------|---------|
| `CommunityNodesStore` | `packages/frontend/editor-ui/src/features/settings/communityNodes/communityNodes.store.ts` | åŠŸèƒ½è¢« `CustomNodesStore` æ›¿ä»£ |
| `CommunityPackageInstallModal` | `packages/frontend/editor-ui/src/features/settings/communityNodes/components/CommunityPackageInstallModal.vue` | å®‰è£…æ–¹å¼æ”¹å˜ |
| "å®‰è£…èŠ‚ç‚¹"æŒ‰é’® | èŠ‚ç‚¹åˆ›å»ºå™¨ UI | æ”¹ä¸º"å®‰è£…åˆ°å·¥ä½œç©ºé—´" |

### æ›¿ä»£æ–¹æ¡ˆæ˜ å°„

| åŸåŠŸèƒ½ | æ–°åŠŸèƒ½ | å˜åŒ– |
|--------|--------|------|
| å®‰è£…ç¤¾åŒºèŠ‚ç‚¹åˆ°æœåŠ¡å™¨ | å®‰è£…ç¤¾åŒºèŠ‚ç‚¹åˆ°å·¥ä½œç©ºé—´æ•°æ®åº“ | å·¥ä½œç©ºé—´éš”ç¦» |
| `installed_packages` è¡¨ | `custom_node` è¡¨ï¼ˆ`node_source='npm_community'`ï¼‰ | ç»Ÿä¸€ç®¡ç† |
| æ–‡ä»¶ç³»ç»ŸåŠ è½½èŠ‚ç‚¹ | æ•°æ®åº“åŠ è½½ + VM2æ²™ç®± | å®‰å…¨éš”ç¦» |
| å…¨å±€å¯ç”¨ | å·¥ä½œç©ºé—´ç§æœ‰ | å¤šç§Ÿæˆ·éš”ç¦» |

---

## ğŸ”’ å®‰å…¨æœºåˆ¶

### èŠ‚ç‚¹ä»£ç å®‰å…¨éªŒè¯

```typescript
// packages/cli/src/modules/custom-nodes/node-security.service.ts

@Service()
export class NodeSecurityService {
  /**
   * éªŒè¯èŠ‚ç‚¹ä»£ç å®‰å…¨æ€§
   */
  async validateNodeCode(code: string): Promise<void> {
    // 1. ç¦æ­¢ä½¿ç”¨å±é™©æ¨¡å—
    const dangerousModules = [
      'child_process',
      'fs',
      'path',
      'os',
      'process',
      'eval',
      'Function',
    ];

    for (const module of dangerousModules) {
      if (code.includes(module)) {
        throw new Error(`èŠ‚ç‚¹ä»£ç åŒ…å«å±é™©æ¨¡å—: ${module}`);
      }
    }

    // 2. ç¦æ­¢ä½¿ç”¨å±é™©å‡½æ•°
    const dangerousFunctions = [
      'eval(',
      'Function(',
      'require(',
      '__dirname',
      '__filename',
    ];

    for (const func of dangerousFunctions) {
      if (code.includes(func)) {
        throw new Error(`èŠ‚ç‚¹ä»£ç åŒ…å«å±é™©å‡½æ•°: ${func}`);
      }
    }

    // 3. ä»£ç é•¿åº¦é™åˆ¶ï¼ˆ1MBï¼‰
    if (code.length > 1024 * 1024) {
      throw new Error('èŠ‚ç‚¹ä»£ç è¶…è¿‡å¤§å°é™åˆ¶ï¼ˆ1MBï¼‰');
    }

    // 4. å°è¯•ç¼–è¯‘éªŒè¯è¯­æ³•
    try {
      const ts = require('typescript');
      const result = ts.transpileModule(code, {
        compilerOptions: {
          module: ts.ModuleKind.CommonJS,
          target: ts.ScriptTarget.ES2020,
        },
      });

      if (result.diagnostics && result.diagnostics.length > 0) {
        throw new Error('èŠ‚ç‚¹ä»£ç å­˜åœ¨è¯­æ³•é”™è¯¯');
      }
    } catch (error) {
      throw new Error(`èŠ‚ç‚¹ä»£ç ç¼–è¯‘å¤±è´¥: ${error.message}`);
    }
  }
}
```

### VM2 æ²™ç®±é…ç½®

```typescript
// ä¸¥æ ¼çš„æ²™ç®±ç¯å¢ƒ
const vm = new VM({
  timeout: 5000, // 5ç§’è¶…æ—¶
  sandbox: {
    // åªå…è®¸è®¿é—®ç™½åå•æ¨¡å—
    require: (moduleName: string) => {
      const allowed = ['n8n-workflow', 'n8n-core'];
      if (!allowed.includes(moduleName)) {
        throw new Error(`æ¨¡å— ${moduleName} ä¸å…è®¸ä½¿ç”¨`);
      }
      return require(moduleName);
    },
  },
  // ç¦æ­¢è®¿é—®å¤–éƒ¨å˜é‡
  eval: false,
  wasm: false,
  fixAsync: false,
});
```

### é…é¢é™åˆ¶

| é™åˆ¶é¡¹ | é»˜è®¤å€¼ | è¯´æ˜ |
|--------|--------|------|
| æ¯å·¥ä½œç©ºé—´èŠ‚ç‚¹æ•° | 50 | é˜²æ­¢æ»¥ç”¨ |
| èŠ‚ç‚¹ä»£ç å¤§å° | 1MB | é˜²æ­¢è¿‡å¤§æ–‡ä»¶ |
| èŠ‚ç‚¹æ‰§è¡Œè¶…æ—¶ | 30ç§’ | é˜²æ­¢æ­»å¾ªç¯ |
| èŠ‚ç‚¹å†…å­˜é™åˆ¶ | 512MB | é˜²æ­¢å†…å­˜æ³„æ¼ |

---

## ğŸ“Š æ•°æ®åº“è®¾è®¡

### custom_node è¡¨

```sql
CREATE TABLE custom_node (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  workspace_id UUID NOT NULL REFERENCES project(id) ON DELETE CASCADE,

  -- èŠ‚ç‚¹æ ‡è¯†
  node_key VARCHAR(100) NOT NULL,  -- ä¾‹å¦‚ï¼š'n8n-nodes-telegram'
  node_name VARCHAR(100) NOT NULL, -- ä¾‹å¦‚ï¼š'Telegram'

  -- èŠ‚ç‚¹æ¥æº
  node_source VARCHAR(50) NOT NULL, -- 'npm_community' | 'user_upload' | 'platform_shared'

  -- npm ç¤¾åŒºèŠ‚ç‚¹ä¸“ç”¨å­—æ®µ
  npm_package_name VARCHAR(200),    -- ä¾‹å¦‚ï¼š'n8n-nodes-telegram'
  npm_version VARCHAR(50),           -- ä¾‹å¦‚ï¼š'1.5.0'
  npm_author VARCHAR(100),           -- ä½œè€…ä¿¡æ¯

  -- èŠ‚ç‚¹ä»£ç å’Œå…ƒæ•°æ®
  node_code TEXT NOT NULL,           -- èŠ‚ç‚¹ä»£ç ï¼ˆå·²è½¬æ¢å‡­è¯ï¼‰
  metadata JSONB,                    -- èŠ‚ç‚¹æè¿°ã€ç‰ˆæœ¬ã€å›¾æ ‡ç­‰

  -- å®¡æ ¸å’ŒçŠ¶æ€
  is_active BOOLEAN DEFAULT true,
  reviewed_at TIMESTAMP,             -- å®¡æ ¸æ—¶é—´
  review_status VARCHAR(50),         -- 'pending' | 'approved' | 'rejected'

  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),

  UNIQUE(workspace_id, node_key)
);

-- ç´¢å¼•
CREATE INDEX idx_custom_node_workspace ON custom_node(workspace_id);
CREATE INDEX idx_custom_node_source ON custom_node(node_source);
CREATE INDEX idx_custom_node_npm ON custom_node(npm_package_name)
  WHERE npm_package_name IS NOT NULL;
```

---

## âœ… æ€»ç»“

### æ ¸å¿ƒä¼˜åŠ¿

| ä¼˜åŠ¿ | è¯´æ˜ |
|------|------|
| **ç”Ÿæ€ä¿ç•™** | âœ… å®Œå…¨ä¿ç•™ n8n ç¤¾åŒºèŠ‚ç‚¹ç”Ÿæ€ï¼Œç”¨æˆ·å¯ä»¥å®‰è£…ä»»ä½• npm èŠ‚ç‚¹ |
| **å®‰å…¨éš”ç¦»** | âœ… èŠ‚ç‚¹ä»£ç å­˜å‚¨åœ¨æ•°æ®åº“ï¼Œæ²™ç®±è¿è¡Œï¼Œä¸æ±¡æŸ“æœåŠ¡å™¨æ–‡ä»¶ç³»ç»Ÿ |
| **å·¥ä½œç©ºé—´éš”ç¦»** | âœ… æ¯ä¸ªå·¥ä½œç©ºé—´ç‹¬ç«‹å®‰è£…ï¼Œäº’ä¸å½±å“ |
| **ç‰ˆæœ¬ç®¡ç†** | âœ… ä¸åŒå·¥ä½œç©ºé—´å¯ä»¥å®‰è£…åŒä¸€èŠ‚ç‚¹çš„ä¸åŒç‰ˆæœ¬ |
| **è‡ªåŠ¨è½¬æ¢** | âœ… å‡­è¯è‡ªåŠ¨è½¬æ¢ä¸ºèŠ‚ç‚¹å‚æ•°ï¼Œæ— ç¼å…¼å®¹ |
| **ç”¨æˆ·ä½“éªŒ** | âœ… ä¿ç•™"å®‰è£…"çš„æ¦‚å¿µï¼Œç”¨æˆ·ä¹ æƒ¯ä¸å˜ |
| **å¯æ§æ€§** | âœ… å¹³å°ç®¡ç†å‘˜å¯ä»¥å®¡æ ¸å’Œç®¡ç†æ‰€æœ‰èŠ‚ç‚¹ |

### å®æ–½è¦ç‚¹

1. **åºŸå¼ƒåŸæœ‰ç¤¾åŒºèŠ‚ç‚¹åŠŸèƒ½**ï¼ˆæ–‡ä»¶ç³»ç»Ÿå®‰è£…ï¼‰
2. **å®ç° npm ä¸‹è½½æœåŠ¡**ï¼ˆä¸´æ—¶ä¸‹è½½ â†’ æå– â†’ å­˜æ•°æ®åº“ï¼‰
3. **å®ç°å‡­è¯è‡ªåŠ¨è½¬æ¢**ï¼ˆAST è½¬æ¢æŠ€æœ¯ï¼‰
4. **å®ç°å·¥ä½œæµå¯¼å…¥è½¬æ¢**ï¼ˆè‡ªåŠ¨æ£€æµ‹å¹¶è½¬æ¢å‡­è¯å¼•ç”¨ï¼‰
5. **ä¸¥æ ¼çš„å®‰å…¨éªŒè¯**ï¼ˆä»£ç æ‰«æ + VM2 æ²™ç®±ï¼‰
6. **å·¥ä½œç©ºé—´é…é¢é™åˆ¶**ï¼ˆé˜²æ­¢æ»¥ç”¨ï¼‰

---

[â† ä¸Šä¸€ç« ï¼šæ•°æ®åº“è®¾è®¡](./03-æ•°æ®åº“è®¾è®¡.md) | [è¿”å›æ€»è§ˆ](../00-æ€»è§ˆä¸å¯¼èˆª.md) | [ä¸‹ä¸€ç« ï¼šAIæœåŠ¡æ¶æ„ â†’](./05-AIæœåŠ¡æ¶æ„.md)
