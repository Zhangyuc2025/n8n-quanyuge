# èŠ‚ç‚¹æ¶æ„

> **ç‰ˆæœ¬ï¼š** v1.0
> **çŠ¶æ€ï¼š** è®¾è®¡ä¸­

[â† è¿”å›æ€»è§ˆ](../00-æ€»è§ˆä¸å¯¼èˆª.md)

---

## ğŸ”Œ èŠ‚ç‚¹æ¶æ„

### èŠ‚ç‚¹åŠ è½½æœºåˆ¶

```typescript
// packages/cli/src/load-nodes-and-credentials.ts

@Service()
export class LoadNodesAndCredentials {
  /**
   * è·å–æ‰€æœ‰å¯ç”¨èŠ‚ç‚¹ï¼ˆæ ¹æ®å·¥ä½œç©ºé—´ï¼‰
   */
  async getAllNodeTypes(workspaceId?: string): Promise<INodeTypeNameIndex> {
    // 1. åŠ è½½å†…ç½®èŠ‚ç‚¹ï¼ˆ142ä¸ªï¼Œä»æ–‡ä»¶ç³»ç»Ÿï¼‰
    const builtinNodes = await this.loadBuiltinNodes();

    // 2. åŠ è½½å¹³å°èŠ‚ç‚¹ï¼ˆä» platform_node è¡¨ï¼‰
    const platformNodes = await this.loadPlatformNodes();

    // 3. åŠ è½½å·¥ä½œç©ºé—´ç§æœ‰èŠ‚ç‚¹ï¼ˆä» custom_node è¡¨ï¼‰
    const workspaceNodes = workspaceId
      ? await this.loadWorkspaceNodes(workspaceId)
      : {};

    // 4. âœ… éªŒè¯å¹¶åˆå¹¶ï¼ˆä¼˜é›…é™çº§ï¼‰
    return this.validateAndMerge(builtinNodes, platformNodes, workspaceNodes);
  }

  /**
   * ğŸ”§ æ–°å¢ï¼šéªŒè¯èŠ‚ç‚¹å…ƒæ•°æ®å¹¶åˆå¹¶
   * ç¡®ä¿æ‰€æœ‰èŠ‚ç‚¹éƒ½æœ‰å®Œæ•´çš„å…ƒæ•°æ®ï¼Œé¿å…å‰ç«¯å´©æºƒ
   */
  private validateAndMerge(...nodeSets: INodeTypeNameIndex[]): INodeTypeNameIndex {
    const result: INodeTypeNameIndex = {};
    let validCount = 0;
    let invalidCount = 0;

    for (const nodeSet of nodeSets) {
      for (const [name, node] of Object.entries(nodeSet)) {
        try {
          // âœ… éªŒè¯èŠ‚ç‚¹å…ƒæ•°æ®
          this.validateNodeMetadata(node.type.description);
          result[name] = node;
          validCount++;
        } catch (error) {
          // âš ï¸ è®°å½•é”™è¯¯ä½†ä¸ä¸­æ–­åŠ è½½
          this.logger.warn(`Skipping invalid node ${name}:`, error);
          invalidCount++;
          // âœ… ä¼˜é›…é™çº§ï¼šè·³è¿‡æ— æ•ˆèŠ‚ç‚¹ï¼Œç»§ç»­åŠ è½½å…¶ä»–èŠ‚ç‚¹
        }
      }
    }

    this.logger.info(`Node loading: ${validCount} valid, ${invalidCount} invalid (skipped)`);
    return result;
  }

  /**
   * ğŸ”§ æ–°å¢ï¼šéªŒè¯èŠ‚ç‚¹å…ƒæ•°æ®å®Œæ•´æ€§
   */
  private validateNodeMetadata(description: INodeTypeDescription): void {
    // å¿…éœ€å­—æ®µæ£€æŸ¥
    const requiredFields = ['name', 'displayName', 'group', 'description', 'version'];

    for (const field of requiredFields) {
      if (!description[field]) {
        throw new Error(`Missing required field: ${field}`);
      }
    }

    // group å¿…é¡»æ˜¯éç©ºæ•°ç»„
    if (!Array.isArray(description.group) || description.group.length === 0) {
      throw new Error('group must be a non-empty array');
    }

    // version å¿…é¡»æ˜¯æ•°å­—æˆ–æ•°å­—æ•°ç»„
    if (typeof description.version !== 'number' && !Array.isArray(description.version)) {
      throw new Error('version must be a number or array of numbers');
    }
  }

  /**
   * åŠ è½½å¹³å°èŠ‚ç‚¹ï¼ˆplatform + third_partyï¼‰
   */
  private async loadPlatformNodes(): Promise<INodeTypeNameIndex> {
    const nodeTypes: INodeTypeNameIndex = {};

    try {
      // æŸ¥è¯¢ï¼šnode_type IN ('platform_official', 'third_party_approved') AND is_active = true
      const platformNodes = await this.customNodeService.getPlatformNodes();

      for (const node of platformNodes) {
        try {
          // ç¼–è¯‘èŠ‚ç‚¹ä»£ç 
          const NodeClass = this.compileNodeCode(node.nodeCode);
          const nodeInstance = new NodeClass();

          // âœ… éªŒè¯å…ƒæ•°æ®
          this.validateNodeMetadata(nodeInstance.description);

          nodeTypes[node.nodeKey] = {
            type: nodeInstance,
            sourcePath: `platform://${node.nodeKey}`,
            source: 'platform',
            nodeType: node.nodeType,
          };
        } catch (error) {
          this.logger.warn(`Failed to load platform node ${node.nodeKey}:`, error);
        }
      }
    } catch (error) {
      this.logger.error('Failed to load platform nodes:', error);
    }

    return nodeTypes;
  }

  /**
   * åŠ è½½å·¥ä½œç©ºé—´ç§æœ‰èŠ‚ç‚¹
   */
  private async loadWorkspaceNodes(workspaceId: string): Promise<INodeTypeNameIndex> {
    const nodeTypes: INodeTypeNameIndex = {};

    try {
      const customNodes = await this.customNodeService.getWorkspaceNodes(workspaceId);

      for (const node of customNodes) {
        try {
          const NodeClass = this.compileNodeCode(node.nodeCode);
          const nodeInstance = new NodeClass();

          this.validateNodeMetadata(nodeInstance.description);

          nodeTypes[node.nodeKey] = {
            type: nodeInstance,
            sourcePath: `custom://${node.id}`,
            source: 'custom',
            nodeType: 'workspace',
          };
        } catch (error) {
          this.logger.warn(`Failed to load custom node ${node.nodeKey}:`, error);
        }
      }
    } catch (error) {
      this.logger.error('Failed to load custom nodes:', error);
    }

    return nodeTypes;
  }

  /**
   * ç¼–è¯‘èŠ‚ç‚¹ä»£ç ï¼ˆå®‰å…¨æ²™ç®±ï¼‰
   */
  private compileNodeCode(code: string): any {
    try {
      const { VM } = require('vm2');
      const vm = new VM({
        timeout: 5000,
        sandbox: {
          require: this.createSandboxRequire(),
        },
      });

      const compiledCode = vm.run(code);

      if (typeof compiledCode !== 'function') {
        throw new Error('Node code must export a class');
      }

      return compiledCode;
    } catch (error) {
      throw new Error(`Node compilation failed: ${error.message}`);
    }
  }

  /**
   * åˆ›å»ºå®‰å…¨çš„ require å‡½æ•°
   */
  private createSandboxRequire() {
    const allowedModules = ['n8n-workflow', 'n8n-core'];

    return (moduleName: string) => {
      if (!allowedModules.includes(moduleName)) {
        throw new Error(`Module ${moduleName} is not allowed`);
      }
      return require(moduleName);
    };
  }
}
```

### èŠ‚ç‚¹åˆ†ç±»è§„åˆ™

```typescript
// èŠ‚ç‚¹æ¥æºæ ‡è¯†
interface ILoadedNode {
  type: INodeType;
  sourcePath: string;
  source: 'builtin' | 'platform' | 'custom';
  nodeType?: string; // 'platform_official' | 'third_party_approved' | 'workspace'
}

// å‰ç«¯åˆ†ç±»é€»è¾‘
const builtinNodes = nodes.filter(n => n.source === 'builtin');
const platformNodes = nodes.filter(n =>
  n.nodeType === 'platform_official' || n.nodeType === 'third_party_approved'
);
const customNodes = nodes.filter(n => n.nodeType === 'workspace');
```

---


[â† ä¸Šä¸€ç« ï¼šæ•°æ®åº“è®¾è®¡](./03-æ•°æ®åº“è®¾è®¡.md) | [è¿”å›æ€»è§ˆ](../00-æ€»è§ˆä¸å¯¼èˆª.md) | [ä¸‹ä¸€ç« ï¼šAIæœåŠ¡æ¶æ„ â†’](./05-AIæœåŠ¡æ¶æ„.md)
