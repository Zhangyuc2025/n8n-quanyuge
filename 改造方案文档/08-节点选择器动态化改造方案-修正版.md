# èŠ‚ç‚¹é€‰æ‹©å™¨åŠ¨æ€åŒ–æ”¹é€ æ–¹æ¡ˆï¼ˆä¿®æ­£ç‰ˆï¼‰

> **æ–‡æ¡£ç‰ˆæœ¬ï¼š** v2.1ï¼ˆç´§æ€¥ä¿®æ­£ç‰ˆï¼‰
> **åˆ›å»ºæ—¥æœŸï¼š** 2025-11-09
> **æœ€åæ›´æ–°ï¼š** 2025-11-09ï¼ˆåŸºäºå‰ç«¯å´©æºƒé—®é¢˜çš„ç´§æ€¥ä¿®æ­£ï¼‰
> **ä¿®æ­£è¯´æ˜ï¼š**
> - å¹³å°èŠ‚ç‚¹å’Œç¬¬ä¸‰æ–¹èŠ‚ç‚¹æ— éœ€å®‰è£…ï¼Œå…¨å¹³å°å¯ç”¨
> - **ç´§æ€¥ï¼š** åŠ å…¥å…ƒæ•°æ®éªŒè¯å’Œé”™è¯¯å¤„ç†ï¼Œè§£å†³å‰ç«¯å´©æºƒé—®é¢˜
> **é¢„è®¡å·¥æœŸï¼š** 4-5 å¤©

---

## ğŸš¨ ç´§æ€¥é—®é¢˜è¯´æ˜

### å‘ç°çš„ä¸¥é‡é—®é¢˜

**ç—‡çŠ¶ï¼š** åˆ é™¤èŠ‚ç‚¹åï¼Œå‰ç«¯å´©æºƒæŠ¥é”™ï¼š
```javascript
TypeError: Cannot read properties of undefined (reading 'includes')
    at useActionsGeneration.ts:390
    // node.group.includes('trigger')
    // â†‘ group æ˜¯ undefined
```

**æ ¹æœ¬åŸå› ï¼š**
1. package.json å¼•ç”¨äº†å·²åˆ é™¤çš„èŠ‚ç‚¹
2. åç«¯å°è¯•åŠ è½½ä¸å­˜åœ¨çš„èŠ‚ç‚¹æ–‡ä»¶
3. è¿”å›ä¸å®Œæ•´çš„èŠ‚ç‚¹å…ƒæ•°æ®ï¼ˆgroup: undefinedï¼‰
4. å‰ç«¯ä»£ç å‡è®¾æ‰€æœ‰å±æ€§éƒ½å­˜åœ¨ â†’ å´©æºƒ

**ä¸´æ—¶ä¿®å¤ï¼ˆå·²å®Œæˆï¼‰ï¼š**
- âœ… æ›´æ–° package.jsonï¼Œç§»é™¤å·²åˆ é™¤èŠ‚ç‚¹å¼•ç”¨
- âœ… å‰ç«¯æ·»åŠ ç©ºå€¼æ£€æŸ¥ï¼š`node.group && !node.group.includes('trigger')`

**æ ¹æœ¬è§£å†³æ–¹æ¡ˆï¼ˆæœ¬æ–¹æ¡ˆï¼‰ï¼š**
- âœ… åç«¯å¼ºåˆ¶éªŒè¯å…ƒæ•°æ®å®Œæ•´æ€§
- âœ… å‰ç«¯ä» API åŠ è½½èŠ‚ç‚¹ï¼Œä¿¡ä»»åç«¯æ•°æ®
- âœ… ä¼˜é›…é™çº§ï¼Œé¿å…å•ä¸ªèŠ‚ç‚¹é”™è¯¯å½±å“æ•´ä½“

---

## ğŸ“‹ æ ¸å¿ƒè®¾è®¡ä¿®æ­£

### âŒ é”™è¯¯ç†è§£ï¼ˆv1.0ï¼‰
- å¹³å°èŠ‚ç‚¹éœ€è¦ç”¨æˆ·"å®‰è£…"åˆ°å·¥ä½œç©ºé—´æ‰èƒ½ä½¿ç”¨
- èŠ‚ç‚¹é€‰æ‹©å™¨æœ‰"å¸‚åœº"Tabï¼Œæ˜¾ç¤ºæœªå®‰è£…èŠ‚ç‚¹
- ç”¨æˆ·ç‚¹å‡»"å®‰è£…"æŒ‰é’®å¤åˆ¶èŠ‚ç‚¹åˆ°å·¥ä½œç©ºé—´

### âœ… æ­£ç¡®ç†è§£ï¼ˆv2.0ï¼‰
- **å¹³å°èŠ‚ç‚¹** + **ç¬¬ä¸‰æ–¹èŠ‚ç‚¹** = å…¨å¹³å°å…±äº«ï¼Œæ‰€æœ‰ç”¨æˆ·ç›´æ¥å¯ç”¨
- **å·¥ä½œç©ºé—´ç§æœ‰èŠ‚ç‚¹** = åªæœ‰æœ¬å·¥ä½œç©ºé—´å¯è§
- èŠ‚ç‚¹é€‰æ‹©å™¨**ä¸éœ€è¦å®‰è£…æµç¨‹**

---

## ğŸ¯ èŠ‚ç‚¹åˆ†ç±»å’Œå¯è§æ€§

### èŠ‚ç‚¹ç±»å‹å®šä¹‰

```typescript
// custom_node è¡¨çš„ node_type å­—æ®µ
type NodeType =
  | 'platform'      // å¹³å°èŠ‚ç‚¹ï¼šç®¡ç†å‘˜ä¸Šä¼ ï¼Œå…¨å¹³å°å¯ç”¨
  | 'third_party'   // ç¬¬ä¸‰æ–¹èŠ‚ç‚¹ï¼šå¼€å‘è€…æäº¤â†’å®¡æ ¸é€šè¿‡ï¼Œå…¨å¹³å°å¯ç”¨
  | 'workspace';    // å·¥ä½œç©ºé—´ç§æœ‰ï¼šæœ¬å·¥ä½œç©ºé—´ä¸Šä¼ ï¼Œä»…æœ¬å·¥ä½œç©ºé—´å¯è§
```

### èŠ‚ç‚¹å¯è§æ€§è§„åˆ™

| èŠ‚ç‚¹ç±»å‹ | å­˜å‚¨ä½ç½® | å¯è§èŒƒå›´ | è°å¯ä»¥ä¸Šä¼  |
|---------|---------|---------|-----------|
| **å†…ç½®èŠ‚ç‚¹** | æ–‡ä»¶ç³»ç»Ÿ | æ‰€æœ‰ç”¨æˆ· | n8n å®˜æ–¹ |
| **å¹³å°èŠ‚ç‚¹** | æ•°æ®åº“ `node_type='platform'` | æ‰€æœ‰ç”¨æˆ· | ç®¡ç†å‘˜ |
| **ç¬¬ä¸‰æ–¹èŠ‚ç‚¹** | æ•°æ®åº“ `node_type='third_party'` | æ‰€æœ‰ç”¨æˆ· | å¼€å‘è€…â†’å®¡æ ¸ |
| **å·¥ä½œç©ºé—´ç§æœ‰** | æ•°æ®åº“ `node_type='workspace'` + `workspace_id=xxx` | ä»…æœ¬å·¥ä½œç©ºé—´ | å·¥ä½œç©ºé—´æˆå‘˜ |

---

## ğŸ”§ åç«¯å®ç°ï¼ˆä¿®æ­£ç‰ˆï¼‰

### 4.1 èŠ‚ç‚¹åŠ è½½é€»è¾‘ï¼ˆåŠ å…¥å…ƒæ•°æ®éªŒè¯ï¼‰

**æ–‡ä»¶ï¼š** `packages/cli/src/services/load-nodes-and-credentials.service.ts`

```typescript
@Service()
export class LoadNodesAndCredentials {
  constructor(
    private readonly customNodeService: CustomNodeService,
    private readonly logger: Logger,
  ) {}

  /**
   * âœ… è·å–æ‰€æœ‰å¯ç”¨èŠ‚ç‚¹ï¼ˆæ ¹æ®å·¥ä½œç©ºé—´ï¼‰
   * ğŸ”§ æ–°å¢ï¼šå…ƒæ•°æ®éªŒè¯å’Œé”™è¯¯å¤„ç†
   */
  async getAllNodeTypes(workspaceId?: string): Promise<INodeTypeNameIndex> {
    // 1. åŠ è½½å†…ç½®èŠ‚ç‚¹ï¼ˆ142ä¸ªï¼‰
    const builtinNodes = await this.loadBuiltinNodes();

    // 2. åŠ è½½å…¨å¹³å°å…±äº«èŠ‚ç‚¹ï¼ˆplatform + third_partyï¼‰
    const sharedNodes = await this.loadSharedNodes();

    // 3. åŠ è½½å·¥ä½œç©ºé—´ç§æœ‰èŠ‚ç‚¹
    const workspaceNodes = workspaceId
      ? await this.loadWorkspaceNodes(workspaceId)
      : {};

    // 4. ğŸ”§ æ–°å¢ï¼šéªŒè¯å¹¶åˆå¹¶ï¼ˆä¼˜å…ˆçº§ï¼šworkspace > shared > builtinï¼‰
    return this.validateAndMerge(builtinNodes, sharedNodes, workspaceNodes);
  }

  /**
   * ğŸ”§ æ–°å¢ï¼šéªŒè¯å…ƒæ•°æ®å¹¶åˆå¹¶èŠ‚ç‚¹
   * ç¡®ä¿æ‰€æœ‰èŠ‚ç‚¹éƒ½æœ‰å®Œæ•´çš„å…ƒæ•°æ®ï¼Œé¿å…å‰ç«¯å´©æºƒ
   */
  private validateAndMerge(
    ...nodeSets: INodeTypeNameIndex[]
  ): INodeTypeNameIndex {
    const result: INodeTypeNameIndex = {};
    let validCount = 0;
    let invalidCount = 0;

    for (const nodeSet of nodeSets) {
      for (const [name, node] of Object.entries(nodeSet)) {
        try {
          // âœ… éªŒè¯èŠ‚ç‚¹å…ƒæ•°æ®
          this.validateNodeMetadata(node.type.description);

          result[name] = node;
          validCount++;
        } catch (error) {
          // âš ï¸ è®°å½•é”™è¯¯ä½†ä¸ä¸­æ–­åŠ è½½
          this.logger.warn(`Skipping invalid node ${name}:`, error);
          invalidCount++;
          // âœ… ä¼˜é›…é™çº§ï¼šè·³è¿‡æ— æ•ˆèŠ‚ç‚¹ï¼Œç»§ç»­åŠ è½½å…¶ä»–èŠ‚ç‚¹
        }
      }
    }

    this.logger.info(
      `Node loading complete: ${validCount} valid, ${invalidCount} invalid (skipped)`
    );

    return result;
  }

  /**
   * ğŸ”§ æ–°å¢ï¼šéªŒè¯èŠ‚ç‚¹å…ƒæ•°æ®å®Œæ•´æ€§
   */
  private validateNodeMetadata(description: INodeTypeDescription): void {
    // å¿…éœ€å­—æ®µæ£€æŸ¥
    const requiredFields = [
      'name',
      'displayName',
      'group',
      'description',
      'version',
    ];

    for (const field of requiredFields) {
      if (!description[field]) {
        throw new Error(`Missing required field: ${field}`);
      }
    }

    // group å¿…é¡»æ˜¯éç©ºæ•°ç»„
    if (!Array.isArray(description.group) || description.group.length === 0) {
      throw new Error('group must be a non-empty array');
    }

    // version å¿…é¡»æ˜¯æ•°å­—æˆ–æ•°å­—æ•°ç»„
    if (
      typeof description.version !== 'number' &&
      !Array.isArray(description.version)
    ) {
      throw new Error('version must be a number or array of numbers');
    }

    // âœ… ç¡®ä¿å…³é”®å±æ€§ç±»å‹æ­£ç¡®
    if (typeof description.name !== 'string') {
      throw new Error('name must be a string');
    }
    if (typeof description.displayName !== 'string') {
      throw new Error('displayName must be a string');
    }
  }

  /**
   * åŠ è½½å†…ç½®èŠ‚ç‚¹ï¼ˆ142ä¸ªï¼‰
   * ğŸ”§ æ–°å¢ï¼šé”™è¯¯å¤„ç†ï¼Œå•ä¸ªèŠ‚ç‚¹å¤±è´¥ä¸å½±å“æ•´ä½“
   */
  private async loadBuiltinNodes(): Promise<INodeTypeNameIndex> {
    const nodeTypes: INodeTypeNameIndex = {};

    try {
      // æ‰«æ packages/nodes-base/nodes ç›®å½•
      const nodeFiles = await this.discoverNodeFiles('packages/nodes-base/nodes');

      for (const nodeFile of nodeFiles) {
        try {
          // åŠ¨æ€åŠ è½½èŠ‚ç‚¹
          const NodeClass = require(nodeFile.path);
          const nodeInstance = new NodeClass();

          // âœ… éªŒè¯å…ƒæ•°æ®ï¼ˆåœ¨æ·»åŠ åˆ°ç»“æœå‰ï¼‰
          this.validateNodeMetadata(nodeInstance.description);

          nodeTypes[nodeInstance.description.name] = {
            type: nodeInstance,
            sourcePath: nodeFile.path,
            source: 'builtin',
          };
        } catch (error) {
          // âš ï¸ å•ä¸ªèŠ‚ç‚¹å¤±è´¥ä¸å½±å“å…¶ä»–èŠ‚ç‚¹
          this.logger.warn(`Failed to load builtin node ${nodeFile.path}:`, error);
        }
      }
    } catch (error) {
      this.logger.error('Failed to load builtin nodes:', error);
      // âœ… å³ä½¿åŠ è½½å¤±è´¥ï¼Œä¹Ÿè¿”å›ç©ºå¯¹è±¡è€Œä¸æ˜¯æŠ›å‡ºå¼‚å¸¸
    }

    return nodeTypes;
  }

  /**
   * âœ… åŠ è½½å…¨å¹³å°å…±äº«èŠ‚ç‚¹ï¼ˆplatform + third_partyï¼‰
   * ğŸ”§ æ–°å¢ï¼šç¼–è¯‘é”™è¯¯å¤„ç†
   */
  private async loadSharedNodes(): Promise<INodeTypeNameIndex> {
    const nodeTypes: INodeTypeNameIndex = {};

    try {
      // æŸ¥è¯¢ï¼šnode_type IN ('platform', 'third_party') AND submission_status = 'approved'
      const sharedNodes = await this.customNodeService.getSharedNodes();

      for (const node of sharedNodes) {
        try {
          // ç¼–è¯‘èŠ‚ç‚¹ä»£ç 
          const NodeClass = this.compileNodeCode(node.nodeCode);
          const nodeInstance = new NodeClass();

          // âœ… éªŒè¯å…ƒæ•°æ®ï¼ˆåœ¨æ·»åŠ åˆ°ç»“æœå‰ï¼‰
          this.validateNodeMetadata(nodeInstance.description);

          nodeTypes[node.nodeKey] = {
            type: nodeInstance,
            sourcePath: `custom://${node.id}`,
            source: 'custom',
            nodeType: node.nodeType, // 'platform' | 'third_party'
            nodeId: node.id,
          };
        } catch (error) {
          // âš ï¸ è®°å½•é”™è¯¯ï¼Œæ ‡è®°èŠ‚ç‚¹ä¸ºå¤±è´¥çŠ¶æ€ï¼ˆå¯é€‰ï¼‰
          this.logger.warn(
            `Failed to load shared node ${node.nodeKey} (${node.id}):`,
            error
          );

          // ğŸ”§ å¯é€‰ï¼šæ›´æ–°æ•°æ®åº“æ ‡è®°æ­¤èŠ‚ç‚¹æœ‰é—®é¢˜
          await this.customNodeService.markNodeAsError(node.id, error.message);
        }
      }
    } catch (error) {
      this.logger.error('Failed to load shared nodes:', error);
    }

    return nodeTypes;
  }

  /**
   * âœ… åŠ è½½å·¥ä½œç©ºé—´ç§æœ‰èŠ‚ç‚¹
   */
  private async loadWorkspaceNodes(workspaceId: string): Promise<INodeTypeNameIndex> {
    // æŸ¥è¯¢ï¼šworkspace_id = xxx AND node_type = 'workspace'
    const workspaceNodes = await this.customNodeService.getWorkspaceNodes(workspaceId);

    const nodeTypes: INodeTypeNameIndex = {};

    for (const node of workspaceNodes) {
      const NodeClass = this.compileNodeCode(node.nodeCode);
      nodeTypes[node.nodeKey] = {
        type: new NodeClass(),
        sourcePath: `custom://${node.id}`,
        source: 'custom',
        nodeType: 'workspace',
        nodeId: node.id,
      };
    }

    return nodeTypes;
  }

  /**
   * ç¼–è¯‘èŠ‚ç‚¹ä»£ç 
   * ğŸ”§ æ–°å¢ï¼šæ›´ä¸¥æ ¼çš„é”™è¯¯å¤„ç†
   */
  private compileNodeCode(code: string): any {
    try {
      // ä½¿ç”¨ vm2 æˆ–ç±»ä¼¼æ²™ç®±ç¯å¢ƒç¼–è¯‘
      const { VM } = require('vm2');
      const vm = new VM({
        timeout: 5000,
        sandbox: {
          require: this.createSandboxRequire(),
        },
      });

      const compiledCode = vm.run(code);

      // âœ… éªŒè¯è¿”å›çš„æ˜¯ä¸€ä¸ªç±»
      if (typeof compiledCode !== 'function') {
        throw new Error('Node code must export a class');
      }

      return compiledCode;
    } catch (error) {
      this.logger.error('Failed to compile node code:', error);
      throw new Error(`Node compilation failed: ${error.message}`);
    }
  }

  /**
   * ğŸ”§ æ–°å¢ï¼šåˆ›å»ºæ²™ç®± require å‡½æ•°
   */
  private createSandboxRequire() {
    // åªå…è®¸å®‰å…¨çš„ä¾èµ–
    const allowedModules = [
      'n8n-workflow',
      'n8n-core',
      // ... å…¶ä»–å®‰å…¨çš„æ¨¡å—
    ];

    return (moduleName: string) => {
      if (!allowedModules.includes(moduleName)) {
        throw new Error(`Module ${moduleName} is not allowed`);
      }
      return require(moduleName);
    };
  }
}
```

### 4.2 CustomNodeService æ‰©å±•

**æ–‡ä»¶ï¼š** `packages/cli/src/services/custom-node.service.ts`

```typescript
@Service()
export class CustomNodeService {
  /**
   * âœ… è·å–å…¨å¹³å°å…±äº«èŠ‚ç‚¹ï¼ˆplatform + third_partyï¼‰
   */
  async getSharedNodes() {
    return await this.customNodeRepository.find({
      where: {
        nodeType: In(['platform', 'third_party']),
        submissionStatus: 'approved',
        isActive: true,
      },
      order: { createdAt: 'DESC' },
    });
  }

  /**
   * âœ… è·å–å·¥ä½œç©ºé—´ç§æœ‰èŠ‚ç‚¹
   */
  async getWorkspaceNodes(workspaceId: string) {
    return await this.customNodeRepository.find({
      where: {
        workspaceId,
        nodeType: 'workspace',
        isActive: true,
      },
      order: { createdAt: 'DESC' },
    });
  }

  /**
   * âœ… åˆ›å»ºå·¥ä½œç©ºé—´ç§æœ‰èŠ‚ç‚¹
   */
  async createWorkspaceNode(
    workspaceId: string,
    userId: string,
    data: {
      nodeKey: string;
      nodeName: string;
      nodeDefinition: any;
      nodeCode: string;
      category?: string;
      description?: string;
    }
  ) {
    const node = this.customNodeRepository.create({
      ...data,
      workspaceId,
      createdBy: userId,
      nodeType: 'workspace',  // âœ… æ ‡è®°ä¸ºå·¥ä½œç©ºé—´ç§æœ‰
      submissionStatus: 'draft', // ç§æœ‰èŠ‚ç‚¹é»˜è®¤è‰ç¨¿çŠ¶æ€
      isActive: true,
    });

    return await this.customNodeRepository.save(node);
  }

  /**
   * âœ… æäº¤å·¥ä½œç©ºé—´èŠ‚ç‚¹åˆ°å¹³å°å®¡æ ¸
   */
  async submitNodeForReview(nodeId: string) {
    const node = await this.customNodeRepository.findOneOrFail({
      where: { id: nodeId },
    });

    // åªæœ‰å·¥ä½œç©ºé—´ç§æœ‰èŠ‚ç‚¹å¯ä»¥æäº¤å®¡æ ¸
    if (node.nodeType !== 'workspace') {
      throw new Error('åªæœ‰å·¥ä½œç©ºé—´ç§æœ‰èŠ‚ç‚¹å¯ä»¥æäº¤å®¡æ ¸');
    }

    node.submissionStatus = 'pending';
    node.submittedAt = new Date();

    return await this.customNodeRepository.save(node);
  }

  /**
   * âœ… ç®¡ç†å‘˜å®¡æ ¸èŠ‚ç‚¹ï¼ˆé€šè¿‡åå˜ä¸ºç¬¬ä¸‰æ–¹èŠ‚ç‚¹ï¼‰
   */
  async reviewNode(
    nodeId: string,
    status: 'approved' | 'rejected',
    reviewerId: string,
    notes?: string
  ) {
    const node = await this.customNodeRepository.findOneOrFail({
      where: { id: nodeId },
    });

    node.submissionStatus = status;
    node.reviewedBy = reviewerId;
    node.reviewedAt = new Date();
    node.reviewNotes = notes;

    if (status === 'approved') {
      // âœ… å®¡æ ¸é€šè¿‡åï¼Œä»å·¥ä½œç©ºé—´ç§æœ‰å˜ä¸ºç¬¬ä¸‰æ–¹èŠ‚ç‚¹ï¼ˆå…¨å¹³å°å¯ç”¨ï¼‰
      node.nodeType = 'third_party';
      node.workspaceId = null; // æ¸…ç©ºå·¥ä½œç©ºé—´ IDï¼Œè¡¨ç¤ºå…¨å¹³å°å¯ç”¨
    }

    return await this.customNodeRepository.save(node);
  }
}
```

### 4.3 API ç«¯ç‚¹ï¼ˆä¿®æ­£ç‰ˆï¼‰

**æ–‡ä»¶ï¼š** `packages/cli/src/controllers/node-types.controller.ts`

```typescript
@RestController('/node-types')
export class NodeTypesController {
  /**
   * âœ… è·å–æ‰€æœ‰å¯ç”¨èŠ‚ç‚¹ï¼ˆå†…ç½® + å¹³å° + ç¬¬ä¸‰æ–¹ + å·¥ä½œç©ºé—´ç§æœ‰ï¼‰
   */
  @Get('/')
  async getAllNodeTypes(
    @WorkspaceContext() context: { workspaceId: string }
  ) {
    const allNodeTypes = await this.loadNodesAndCredentials.getAllNodeTypes(
      context.workspaceId
    );

    return Object.values(allNodeTypes).map(node => ({
      ...node.type.description,
      source: node.source,
      nodeType: node.nodeType,
      nodeId: node.nodeId,
    }));
  }
}
```

**æ–‡ä»¶ï¼š** `packages/cli/src/controllers/custom-nodes.controller.ts`

```typescript
@RestController('/custom-nodes')
export class CustomNodesController {
  /**
   * âœ… ç”¨æˆ·ä¸Šä¼ å·¥ä½œç©ºé—´ç§æœ‰èŠ‚ç‚¹
   */
  @Post('/workspace')
  async uploadWorkspaceNode(
    @Body() body: {
      nodeKey: string;
      nodeName: string;
      nodeDefinition: any;
      nodeCode: string;
      category?: string;
      description?: string;
    },
    @WorkspaceContext() context: { workspaceId: string; userId: string }
  ) {
    return await this.customNodeService.createWorkspaceNode(
      context.workspaceId,
      context.userId,
      body
    );
  }

  /**
   * âœ… æäº¤å·¥ä½œç©ºé—´èŠ‚ç‚¹åˆ°å¹³å°å®¡æ ¸
   */
  @Post('/:nodeId/submit')
  async submitForReview(
    @Param('nodeId') nodeId: string
  ) {
    return await this.customNodeService.submitNodeForReview(nodeId);
  }
}
```

---

## ğŸ¨ å‰ç«¯å®ç°ï¼ˆä¿®æ­£ç‰ˆï¼‰

### 5.1 Store æ”¹é€ ï¼ˆåŠ å…¥å®‰å…¨è®¿é—®ï¼‰

**æ–‡ä»¶ï¼š** `packages/editor-ui/src/stores/nodeTypes.store.ts`

```typescript
export const useNodeTypesStore = defineStore('nodeTypes', () => {
  const nodeTypes = ref<Record<string, INodeTypeWithSource>>({});
  const loading = ref(false);
  const error = ref<Error | null>(null);

  /**
   * âœ… åŠ è½½æ‰€æœ‰å¯ç”¨èŠ‚ç‚¹
   * åŒ…æ‹¬ï¼šå†…ç½® + å¹³å° + ç¬¬ä¸‰æ–¹ + å·¥ä½œç©ºé—´ç§æœ‰
   * ğŸ”§ æ–°å¢ï¼šé”™è¯¯å¤„ç†å’ŒåŠ è½½çŠ¶æ€
   */
  async function fetchNodeTypes() {
    loading.value = true;
    error.value = null;

    try {
      const nodes = await nodeTypesApi.getAllNodeTypes();

      nodeTypes.value = {};
      for (const node of nodes) {
        // âœ… åç«¯å·²éªŒè¯å…ƒæ•°æ®ï¼Œå‰ç«¯å¯ä»¥ä¿¡ä»»æ•°æ®
        // ä½†ä»ç„¶åšåŸºæœ¬çš„ç©ºå€¼æ£€æŸ¥
        if (node && node.name) {
          nodeTypes.value[node.name] = node;
        } else {
          console.warn('Received invalid node from API:', node);
        }
      }
    } catch (err) {
      error.value = err as Error;
      console.error('Failed to load node types:', err);
      // âœ… ä¸æŠ›å‡ºå¼‚å¸¸ï¼Œå…è®¸åº”ç”¨ç»§ç»­è¿è¡Œ
    } finally {
      loading.value = false;
    }
  }

  /**
   * ğŸ”§ æ–°å¢ï¼šå®‰å…¨è·å–èŠ‚ç‚¹
   */
  function getNodeType(name: string): INodeTypeWithSource | null {
    return nodeTypes.value[name] || null;
  }

  /**
   * ğŸ”§ æ–°å¢ï¼šå®‰å…¨è·å–èŠ‚ç‚¹å±æ€§
   */
  function getNodeProperty<K extends keyof INodeTypeDescription>(
    nodeName: string,
    property: K
  ): INodeTypeDescription[K] | undefined {
    const node = nodeTypes.value[nodeName];
    return node?.[property];
  }

  /**
   * è®¡ç®—å±æ€§ï¼šå†…ç½®èŠ‚ç‚¹ï¼ˆ142ä¸ªï¼‰
   */
  const builtinNodes = computed(() =>
    Object.values(nodeTypes.value).filter(node => node.source === 'builtin')
  );

  /**
   * âœ… è®¡ç®—å±æ€§ï¼šæ‰©å±•èŠ‚ç‚¹ï¼ˆå¹³å° + ç¬¬ä¸‰æ–¹ï¼Œå…¨å¹³å°å¯ç”¨ï¼‰
   */
  const extensionNodes = computed(() =>
    Object.values(nodeTypes.value).filter(
      node => node.nodeType === 'platform' || node.nodeType === 'third_party'
    )
  );

  /**
   * âœ… è®¡ç®—å±æ€§ï¼šå·¥ä½œç©ºé—´ç§æœ‰èŠ‚ç‚¹
   */
  const workspaceNodes = computed(() =>
    Object.values(nodeTypes.value).filter(
      node => node.nodeType === 'workspace'
    )
  );

  /**
   * ğŸ”§ æ–°å¢ï¼šæŒ‰åˆ†ç±»å®‰å…¨è·å–èŠ‚ç‚¹
   */
  function getNodesByCategory(category: string): INodeTypeWithSource[] {
    return Object.values(nodeTypes.value).filter(node => {
      // âœ… å®‰å…¨è®¿é—® group å±æ€§
      if (!node.group || !Array.isArray(node.group)) {
        console.warn(`Node ${node.name} has invalid group property`);
        return false;
      }
      return node.group.includes(category);
    });
  }

  /**
   * ğŸ”§ æ–°å¢ï¼šæŒ‰ tag å®‰å…¨è¿‡æ»¤èŠ‚ç‚¹
   */
  function getNodesByTag(tag: string): INodeTypeWithSource[] {
    return Object.values(nodeTypes.value).filter(node => {
      // âœ… å®‰å…¨è®¿é—® codex.categories
      if (!node.codex?.categories) return false;

      return Object.values(node.codex.categories)
        .flat()
        .includes(tag);
    });
  }

  return {
    nodeTypes,
    loading,
    error,
    fetchNodeTypes,
    getNodeType,
    getNodeProperty,
    builtinNodes,
    extensionNodes,
    workspaceNodes,
    getNodesByCategory,
    getNodesByTag,
  };
});
```

### 5.2 èŠ‚ç‚¹é€‰æ‹©å™¨ UIï¼ˆä¿®æ­£ç‰ˆï¼‰

**æ–‡ä»¶ï¼š** `packages/editor-ui/src/components/Node/NodeCreator/NodeCreator.vue`

```vue
<template>
  <div class="node-creator">
    <!-- æœç´¢æ¡† -->
    <div class="node-creator-search">
      <n8n-input
        v-model="searchQuery"
        placeholder="æœç´¢èŠ‚ç‚¹..."
        prefix-icon="search"
      />
    </div>

    <!-- âœ… Tab åˆ‡æ¢ï¼ˆä¿®æ­£ç‰ˆï¼‰ -->
    <n8n-tabs v-model="activeTab" class="node-creator-tabs">
      <!-- Tab 1: åŸºç¡€èŠ‚ç‚¹ï¼ˆ142ä¸ªå†…ç½®ï¼‰ -->
      <n8n-tab-pane label="åŸºç¡€èŠ‚ç‚¹" name="builtin">
        <div class="tab-description">
          n8n å†…ç½®çš„æ ¸å¿ƒèŠ‚ç‚¹ï¼Œæ¶µç›–æ•°æ®å¤„ç†ã€æµç¨‹æ§åˆ¶ç­‰åŸºç¡€åŠŸèƒ½
        </div>
        <NodeCategoryList :nodes="filteredBuiltinNodes" />
      </n8n-tab-pane>

      <!-- âœ… Tab 2: æ‰©å±•èŠ‚ç‚¹ï¼ˆå¹³å° + ç¬¬ä¸‰æ–¹ï¼Œå…¨å¹³å°å…±äº«ï¼‰ -->
      <n8n-tab-pane label="æ‰©å±•èŠ‚ç‚¹" name="extension">
        <div class="tab-description">
          å¹³å°æä¾›å’Œç¤¾åŒºè´¡çŒ®çš„èŠ‚ç‚¹ï¼Œæ‰€æœ‰ç”¨æˆ·å¯ç”¨
        </div>

        <!-- åˆ†ç±»ï¼šå¹³å°èŠ‚ç‚¹ -->
        <div class="node-section">
          <h3 class="section-title">
            <n8n-tag type="success" size="small">å¹³å°æä¾›</n8n-tag>
            å¹³å°èŠ‚ç‚¹
          </h3>
          <NodeGrid :nodes="filteredPlatformNodes" />
        </div>

        <!-- åˆ†ç±»ï¼šç¬¬ä¸‰æ–¹èŠ‚ç‚¹ -->
        <div class="node-section">
          <h3 class="section-title">
            <n8n-tag type="info" size="small">ç¤¾åŒºè´¡çŒ®</n8n-tag>
            ç¬¬ä¸‰æ–¹èŠ‚ç‚¹
          </h3>
          <NodeGrid :nodes="filteredThirdPartyNodes" />
        </div>

        <n8n-empty
          v-if="extensionNodes.length === 0"
          description="æš‚æ— æ‰©å±•èŠ‚ç‚¹"
        />
      </n8n-tab-pane>

      <!-- âœ… Tab 3: æˆ‘çš„èŠ‚ç‚¹ï¼ˆå·¥ä½œç©ºé—´ç§æœ‰ï¼‰ -->
      <n8n-tab-pane label="æˆ‘çš„èŠ‚ç‚¹" name="workspace">
        <div class="tab-description">
          æœ¬å·¥ä½œç©ºé—´ä¸Šä¼ çš„ç§æœ‰èŠ‚ç‚¹ï¼Œä»…å›¢é˜Ÿæˆå‘˜å¯è§
        </div>

        <NodeList :nodes="filteredWorkspaceNodes" />

        <n8n-empty
          v-if="workspaceNodes.length === 0"
          description="è¿˜æ²¡æœ‰ä¸Šä¼ ç§æœ‰èŠ‚ç‚¹"
        >
          <n8n-button @click="showUploadDialog = true" type="primary">
            ä¸Šä¼ èŠ‚ç‚¹
          </n8n-button>
        </n8n-empty>

        <div class="workspace-actions">
          <n8n-button @click="showUploadDialog = true" icon="plus">
            ä¸Šä¼ æ–°èŠ‚ç‚¹
          </n8n-button>
        </div>
      </n8n-tab-pane>
    </n8n-tabs>

    <!-- ä¸Šä¼ å¯¹è¯æ¡† -->
    <NodeUploadDialog
      v-if="showUploadDialog"
      @close="showUploadDialog = false"
      @uploaded="handleNodeUploaded"
    />
  </div>
</template>

<script setup lang="ts">
import { ref, computed, onMounted } from 'vue';
import { useNodeTypesStore } from '@/stores/nodeTypes.store';

const nodeTypesStore = useNodeTypesStore();

const searchQuery = ref('');
const activeTab = ref('builtin');
const showUploadDialog = ref(false);

// å†…ç½®èŠ‚ç‚¹
const builtinNodes = computed(() => nodeTypesStore.builtinNodes);
const filteredBuiltinNodes = computed(() =>
  builtinNodes.value.filter(matchesSearch)
);

// âœ… æ‰©å±•èŠ‚ç‚¹ï¼ˆå¹³å° + ç¬¬ä¸‰æ–¹ï¼‰
const extensionNodes = computed(() => nodeTypesStore.extensionNodes);

const filteredPlatformNodes = computed(() =>
  extensionNodes.value
    .filter(node => node.nodeType === 'platform')
    .filter(matchesSearch)
);

const filteredThirdPartyNodes = computed(() =>
  extensionNodes.value
    .filter(node => node.nodeType === 'third_party')
    .filter(matchesSearch)
);

// âœ… å·¥ä½œç©ºé—´ç§æœ‰èŠ‚ç‚¹
const workspaceNodes = computed(() => nodeTypesStore.workspaceNodes);
const filteredWorkspaceNodes = computed(() =>
  workspaceNodes.value.filter(matchesSearch)
);

function matchesSearch(node: any) {
  if (!searchQuery.value) return true;
  const query = searchQuery.value.toLowerCase();
  return (
    node.displayName?.toLowerCase().includes(query) ||
    node.description?.toLowerCase().includes(query) ||
    node.name?.toLowerCase().includes(query)
  );
}

async function handleNodeUploaded() {
  // é‡æ–°åŠ è½½èŠ‚ç‚¹åˆ—è¡¨
  await nodeTypesStore.fetchNodeTypes();
  // åˆ‡æ¢åˆ°"æˆ‘çš„èŠ‚ç‚¹" Tab
  activeTab.value = 'workspace';
  showUploadDialog.value = false;
}

onMounted(async () => {
  await nodeTypesStore.fetchNodeTypes();
});
</script>

<style scoped lang="scss">
.node-creator {
  height: 100%;
  display: flex;
  flex-direction: column;

  &-search {
    padding: var(--spacing--md);
    border-bottom: var(--border);
  }

  &-tabs {
    flex: 1;
    overflow: hidden;
  }
}

.tab-description {
  padding: var(--spacing--sm) var(--spacing--md);
  font-size: var(--font-size--xs);
  color: var(--color--text--tint-2);
  background: var(--color--background--light-2);
  border-radius: var(--radius);
  margin-bottom: var(--spacing--md);
}

.node-section {
  margin-bottom: var(--spacing--xl);

  .section-title {
    display: flex;
    align-items: center;
    gap: var(--spacing--xs);
    font-size: var(--font-size--md);
    font-weight: var(--font-weight--bold);
    margin-bottom: var(--spacing--sm);
  }
}

.workspace-actions {
  margin-top: var(--spacing--lg);
  text-align: center;
}
</style>
```

---

## ğŸ“Š ç”¨æˆ·ä½“éªŒæµç¨‹ï¼ˆä¿®æ­£ç‰ˆï¼‰

### åœºæ™¯ 1ï¼šæ–°ç”¨æˆ·æ‰“å¼€å·¥ä½œæµç¼–è¾‘å™¨

1. æ‰“å¼€èŠ‚ç‚¹é€‰æ‹©å™¨
2. **Tab 1 - åŸºç¡€èŠ‚ç‚¹**ï¼šçœ‹åˆ° 142 ä¸ªå†…ç½®èŠ‚ç‚¹ï¼ˆSet, If, Code...ï¼‰
3. **Tab 2 - æ‰©å±•èŠ‚ç‚¹**ï¼š
   - å¹³å°èŠ‚ç‚¹ï¼ˆç®¡ç†å‘˜ä¸Šä¼ çš„ï¼‰ï¼šå¦‚"AI æ™ºèƒ½åˆ†æ"ã€"OCR è¯†åˆ«"
   - ç¬¬ä¸‰æ–¹èŠ‚ç‚¹ï¼ˆå®¡æ ¸é€šè¿‡çš„ï¼‰ï¼šå¦‚"GitHub é«˜çº§ç‰ˆ"ã€"Slack å¢å¼ºç‰ˆ"
   - âœ… **ç›´æ¥å¯ç”¨ï¼Œæ— éœ€å®‰è£…**
4. **Tab 3 - æˆ‘çš„èŠ‚ç‚¹**ï¼šç©ºï¼ˆè¿˜æ²¡ä¸Šä¼ ç§æœ‰èŠ‚ç‚¹ï¼‰

### åœºæ™¯ 2ï¼šç”¨æˆ·ä½¿ç”¨å¹³å°èŠ‚ç‚¹

1. åˆ‡æ¢åˆ°"æ‰©å±•èŠ‚ç‚¹" Tab
2. çœ‹åˆ°"AI æ™ºèƒ½åˆ†æ"èŠ‚ç‚¹ï¼ˆå¹³å°èŠ‚ç‚¹ï¼‰
3. ç›´æ¥æ‹–æ‹½åˆ°ç”»å¸ƒä½¿ç”¨
4. âœ… **æ— éœ€å®‰è£…ï¼Œç«‹å³å¯ç”¨**

### åœºæ™¯ 3ï¼šç”¨æˆ·ä¸Šä¼ å·¥ä½œç©ºé—´ç§æœ‰èŠ‚ç‚¹

1. åˆ‡æ¢åˆ°"æˆ‘çš„èŠ‚ç‚¹" Tab
2. ç‚¹å‡»"ä¸Šä¼ èŠ‚ç‚¹"æŒ‰é’®
3. å¡«å†™èŠ‚ç‚¹ä¿¡æ¯ + ä¸Šä¼ ä»£ç 
4. èŠ‚ç‚¹ç«‹å³å‡ºç°åœ¨"æˆ‘çš„èŠ‚ç‚¹" Tab
5. âœ… **ä»…æœ¬å·¥ä½œç©ºé—´å¯è§å¯ç”¨**
6. ï¼ˆå¯é€‰ï¼‰ç‚¹å‡»"æäº¤å®¡æ ¸"ï¼Œå®¡æ ¸é€šè¿‡åå˜ä¸ºç¬¬ä¸‰æ–¹èŠ‚ç‚¹ï¼ˆå…¨å¹³å°å¯ç”¨ï¼‰

### åœºæ™¯ 4ï¼šç®¡ç†å‘˜ä¸Šä¼ å¹³å°èŠ‚ç‚¹

1. ç®¡ç†å‘˜è¿›å…¥åå°ç®¡ç†ç³»ç»Ÿ
2. ä¸Šä¼ æ–°èŠ‚ç‚¹ï¼Œè®¾ç½®ä¸º"å¹³å°èŠ‚ç‚¹"
3. èŠ‚ç‚¹è‡ªåŠ¨å‡ºç°åœ¨æ‰€æœ‰ç”¨æˆ·çš„"æ‰©å±•èŠ‚ç‚¹" Tab
4. âœ… **æ‰€æœ‰ç”¨æˆ·ç«‹å³å¯ç”¨**

### åœºæ™¯ 5ï¼šå¼€å‘è€…æäº¤ç¬¬ä¸‰æ–¹èŠ‚ç‚¹

1. å¼€å‘è€…åœ¨è‡ªå·±å·¥ä½œç©ºé—´ä¸Šä¼ èŠ‚ç‚¹ï¼ˆå·¥ä½œç©ºé—´ç§æœ‰ï¼‰
2. ç‚¹å‡»"æäº¤å®¡æ ¸"
3. ç®¡ç†å‘˜å®¡æ ¸é€šè¿‡
4. èŠ‚ç‚¹ `node_type` ä» `workspace` å˜ä¸º `third_party`
5. èŠ‚ç‚¹å‡ºç°åœ¨æ‰€æœ‰ç”¨æˆ·çš„"æ‰©å±•èŠ‚ç‚¹" Tabï¼ˆç¬¬ä¸‰æ–¹åˆ†ç±»ï¼‰
6. âœ… **å…¨å¹³å°å¯ç”¨**

---

## ğŸ”„ èŠ‚ç‚¹ç”Ÿå‘½å‘¨æœŸ

```mermaid
graph LR
    A[ç”¨æˆ·ä¸Šä¼ èŠ‚ç‚¹] --> B[å·¥ä½œç©ºé—´ç§æœ‰<br/>workspace]
    B --> |ä»…æœ¬å·¥ä½œç©ºé—´å¯è§| B

    B --> |æäº¤å®¡æ ¸| C[å¾…å®¡æ ¸<br/>pending]
    C --> |ç®¡ç†å‘˜å®¡æ ¸| D{å®¡æ ¸ç»“æœ}

    D --> |é€šè¿‡| E[ç¬¬ä¸‰æ–¹èŠ‚ç‚¹<br/>third_party]
    D --> |æ‹’ç»| B

    E --> |å…¨å¹³å°å¯ç”¨| E

    F[ç®¡ç†å‘˜ä¸Šä¼ ] --> G[å¹³å°èŠ‚ç‚¹<br/>platform]
    G --> |å…¨å¹³å°å¯ç”¨| G

    style B fill:#ffd43b
    style E fill:#74c0fc
    style G fill:#51cf66
```

---

## ğŸ—„ï¸ æ•°æ®åº“è®¾è®¡ï¼ˆæ— éœ€ä¿®æ”¹ï¼‰

**`custom_node` è¡¨å·²ç»æ”¯æŒè¿™ä¸ªè®¾è®¡ï¼š**

```sql
CREATE TABLE custom_node (
  id UUID PRIMARY KEY,
  node_key VARCHAR(100) NOT NULL,
  node_name VARCHAR(200) NOT NULL,

  -- âœ… å…³é”®å­—æ®µï¼šèŠ‚ç‚¹ç±»å‹
  node_type VARCHAR(50) DEFAULT 'workspace',  -- 'platform' | 'third_party' | 'workspace'

  -- âœ… å…³é”®å­—æ®µï¼šæ‰€å±å·¥ä½œç©ºé—´ï¼ˆnull = å…¨å¹³å°å¯ç”¨ï¼‰
  workspace_id UUID,                          -- NULL è¡¨ç¤ºå…¨å¹³å°èŠ‚ç‚¹

  node_definition JSONB NOT NULL,
  node_code TEXT NOT NULL,

  -- å®¡æ ¸å­—æ®µ
  submission_status VARCHAR(50),              -- 'draft' | 'pending' | 'approved' | 'rejected'
  submitted_at TIMESTAMP,
  reviewed_by UUID,
  reviewed_at TIMESTAMP,
  review_notes TEXT,

  is_active BOOLEAN NOT NULL DEFAULT true,
  created_by UUID NOT NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

  FOREIGN KEY (workspace_id) REFERENCES project(id) ON DELETE CASCADE,
  UNIQUE(workspace_id, node_key)
);
```

**æŸ¥è¯¢ç¤ºä¾‹ï¼š**

```sql
-- è·å–å…¨å¹³å°å¯ç”¨èŠ‚ç‚¹ï¼ˆå¹³å° + ç¬¬ä¸‰æ–¹ï¼‰
SELECT * FROM custom_node
WHERE node_type IN ('platform', 'third_party')
  AND submission_status = 'approved'
  AND is_active = true;

-- è·å–å·¥ä½œç©ºé—´ç§æœ‰èŠ‚ç‚¹
SELECT * FROM custom_node
WHERE workspace_id = 'xxx'
  AND node_type = 'workspace'
  AND is_active = true;
```

---

## âœ… éªŒæ”¶æ ‡å‡†ï¼ˆä¿®æ­£ç‰ˆï¼‰

### åç«¯éªŒæ”¶
- [ ] `getAllNodeTypes(workspaceId)` è¿”å›ï¼šå†…ç½® + å¹³å° + ç¬¬ä¸‰æ–¹ + å·¥ä½œç©ºé—´ç§æœ‰
- [ ] å¹³å°èŠ‚ç‚¹å’Œç¬¬ä¸‰æ–¹èŠ‚ç‚¹åœ¨æ‰€æœ‰å·¥ä½œç©ºé—´å¯è§
- [ ] å·¥ä½œç©ºé—´ç§æœ‰èŠ‚ç‚¹åªåœ¨æœ¬å·¥ä½œç©ºé—´å¯è§
- [ ] å®¡æ ¸é€šè¿‡åèŠ‚ç‚¹ `node_type` ä» `workspace` å˜ä¸º `third_party`
- [ ] å®¡æ ¸é€šè¿‡åèŠ‚ç‚¹ `workspace_id` å˜ä¸º `null`

### å‰ç«¯éªŒæ”¶
- [ ] èŠ‚ç‚¹é€‰æ‹©å™¨æœ‰ä¸‰ä¸ª Tabï¼šåŸºç¡€èŠ‚ç‚¹ã€æ‰©å±•èŠ‚ç‚¹ã€æˆ‘çš„èŠ‚ç‚¹
- [ ] Tab 1 æ˜¾ç¤º 142 ä¸ªå†…ç½®èŠ‚ç‚¹
- [ ] Tab 2 åˆ†ä¸¤ä¸ªåˆ†ç±»ï¼šå¹³å°èŠ‚ç‚¹ + ç¬¬ä¸‰æ–¹èŠ‚ç‚¹
- [ ] Tab 3 æ˜¾ç¤ºå·¥ä½œç©ºé—´ç§æœ‰èŠ‚ç‚¹
- [ ] âŒ æ²¡æœ‰"å®‰è£…"æŒ‰é’®å’Œæµç¨‹
- [ ] ç”¨æˆ·å¯ä»¥ä¸Šä¼ å·¥ä½œç©ºé—´ç§æœ‰èŠ‚ç‚¹
- [ ] ç”¨æˆ·å¯ä»¥æäº¤èŠ‚ç‚¹å®¡æ ¸

### é›†æˆæµ‹è¯•
- [ ] ç®¡ç†å‘˜ä¸Šä¼ å¹³å°èŠ‚ç‚¹åï¼Œæ‰€æœ‰ç”¨æˆ·ç«‹å³å¯ç”¨
- [ ] ç”¨æˆ·Aä¸Šä¼ å·¥ä½œç©ºé—´èŠ‚ç‚¹ï¼Œç”¨æˆ·Bï¼ˆå…¶ä»–å·¥ä½œç©ºé—´ï¼‰çœ‹ä¸åˆ°
- [ ] ç”¨æˆ·Aæäº¤èŠ‚ç‚¹å®¡æ ¸ï¼Œå®¡æ ¸é€šè¿‡åæ‰€æœ‰ç”¨æˆ·å¯ç”¨
- [ ] æœç´¢åŠŸèƒ½åœ¨æ‰€æœ‰ Tab æ­£å¸¸å·¥ä½œ

---

## ğŸ“Š æ”¹é€ å·¥æœŸï¼ˆä¸å˜ï¼‰

| ä»»åŠ¡ | å·¥ä½œé‡ |
|------|--------|
| åç«¯èŠ‚ç‚¹åŠ è½½æ”¹é€  | 1 å¤© |
| åç«¯ API ç«¯ç‚¹ | 0.5 å¤© |
| å‰ç«¯ Store æ”¹é€  | 0.5 å¤© |
| èŠ‚ç‚¹é€‰æ‹©å™¨ UI | 1.5 å¤© |
| é›†æˆæµ‹è¯• | 0.5 å¤© |
| **æ€»è®¡** | **4 å¤©** |

---

## ğŸ“ å…³é”®ä¿®æ­£ç‚¹æ€»ç»“

| é¡¹ç›® | v1.0ï¼ˆé”™è¯¯ï¼‰ | v2.0ï¼ˆä¿®æ­£ï¼‰ |
|------|-------------|-------------|
| **å¹³å°èŠ‚ç‚¹** | éœ€è¦å®‰è£…åˆ°å·¥ä½œç©ºé—´ | âœ… å…¨å¹³å°å¯ç”¨ï¼Œæ— éœ€å®‰è£… |
| **ç¬¬ä¸‰æ–¹èŠ‚ç‚¹** | éœ€è¦å®‰è£…åˆ°å·¥ä½œç©ºé—´ | âœ… å…¨å¹³å°å¯ç”¨ï¼Œæ— éœ€å®‰è£… |
| **èŠ‚ç‚¹é€‰æ‹©å™¨ Tab** | åŸºç¡€/å·²å®‰è£…/å¸‚åœº | âœ… åŸºç¡€/æ‰©å±•/æˆ‘çš„èŠ‚ç‚¹ |
| **å®‰è£…æµç¨‹** | æœ‰å®‰è£…æŒ‰é’®å’Œ API | âŒ æ— éœ€å®‰è£…æµç¨‹ |
| **èŠ‚ç‚¹å¯è§æ€§** | æŒ‰å®‰è£…çŠ¶æ€ | âœ… æŒ‰èŠ‚ç‚¹ç±»å‹ + å·¥ä½œç©ºé—´ |

---

**æ–‡æ¡£ç‰ˆæœ¬ï¼š** v2.0ï¼ˆä¿®æ­£ç‰ˆï¼‰
**åˆ›å»ºæ—¥æœŸï¼š** 2025-11-09
**ç»´æŠ¤è€…ï¼š** å¼€å‘å›¢é˜Ÿ
